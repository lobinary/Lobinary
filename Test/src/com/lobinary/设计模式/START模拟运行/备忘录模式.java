package com.lobinary.设计模式.START模拟运行;

import com.lobinary.设计模式.备忘录模式.宽接口.备忘对象保存库宽接口;
import com.lobinary.设计模式.备忘录模式.宽接口.备忘对象宽接口;
import com.lobinary.设计模式.备忘录模式.窄接口.备忘对象;
import com.lobinary.设计模式.备忘录模式.窄接口.备忘对象保存库;

/**
 * 备忘录模式
	备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
	介绍
	意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
	主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
	何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。
	如何解决：通过一个备忘录类专门存储对象状态。
	关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。
	应用实例： 
		1、后悔药。 
		2、打游戏时的存档。 
		3、Windows 里的 ctrl + z。 
		4、IE 中的后退。 
		5、数据库的事务管理。
	优点： 
		1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 
		2、实现了信息的封装，使得用户不需要关心状态的保存细节。
	缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
	使用场景： 
		1、需要保存/恢复数据的相关状态场景。 
		2、提供一个可回滚的操作。
	注意事项： 
		1、为了符合迪米特原则，还要增加一个管理备忘录的类。 
		2、为了节约内存，可使用原型模式+备忘录模式。
 */
public class 备忘录模式 {

	/**
	 * 个人理解：
	 * 		
	 * 		这是一种设计思路，也就是加上对原型模式的理解，在进行一些操作需要保存对象状态的时候，
	 * 		可以引入，具体怎么使用和优化使用方案，待使用时继续深入研究，该出为简略方案，不太适合实际使用
	 */
	public static void main(String[] args) {
		窄接口();
		宽接口();
	}

	private static void 宽接口() {
		备忘对象宽接口 备忘对象宽接口 = new 备忘对象宽接口();
		备忘对象保存库宽接口 备忘对象保存库宽接口 = new 备忘对象保存库宽接口();
        //改变负责人对象的状态
        备忘对象宽接口.setState("On");
        //创建备忘录对象，并将发起人对象的状态存储起来
        备忘对象保存库宽接口.保存备忘录对象(备忘对象宽接口.创建备忘录对象());
        //修改发起人对象的状态
        备忘对象宽接口.setState("Off");
        //恢复发起人对象的状态
        备忘对象宽接口.从备忘对象保存库恢复数据(备忘对象保存库宽接口.获取备忘录对象());
	}

	private static void 窄接口() {
		//　发起人角色有如下责任：1.创建一个含有当前的内部状态的备忘录对象。2.使用备忘录对象存储其内部状态。
		备忘对象 备忘对象 = new 备忘对象();
		//负责人角色有如下责任：1.负责保存备忘录对象。2.不检查备忘录对象的内容。
		备忘对象保存库 备忘对象保存库 = new 备忘对象保存库();
		// 改变负责人对象的状态
		备忘对象.setState("On");
		// 创建备忘录对象，并将发起人对象的状态储存起来
		备忘对象保存库.保存备忘录对象(备忘对象.创建备忘录对象());
		// 修改发起人的状态
		备忘对象.setState("Off");
		// 恢复发起人对象的状态
		备忘对象.从备忘对象保存库恢复数据(备忘对象保存库.获取备忘录对象());

		System.out.println(备忘对象.getState());
	}

}
