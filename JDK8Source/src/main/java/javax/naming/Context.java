/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package javax.naming;

import java.util.Hashtable;

/**
 * This interface represents a naming context, which
 * consists of a set of name-to-object bindings.
 * It contains methods for examining and updating these bindings.
 *
 * <h1>Names</h1>
 * Each name passed as an argument to a <tt>Context</tt> method is relative
 * to that context.  The empty name is used to name the context itself.
 * A name parameter may never be null.
 * <p>
 * Most of the methods have overloaded versions with one taking a
 * <code>Name</code> parameter and one taking a <code>String</code>.
 * These overloaded versions are equivalent in that if
 * the <code>Name</code> and <code>String</code> parameters are just
 * different representations of the same name, then the overloaded
 * versions of the same methods behave the same.
 * In the method descriptions below, only one version is fully documented.
 * The second version instead has a link to the first:  the same
 * documentation applies to both.
 * <p>
 * For systems that support federation, <tt>String</tt> name arguments to
 * <tt>Context</tt> methods are composite names. Name arguments that are
 * instances of <tt>CompositeName</tt> are treated as composite names,
 * while <tt>Name</tt> arguments that are not instances of
 * <tt>CompositeName</tt> are treated as compound names (which might be
 * instances of <tt>CompoundName</tt> or other implementations of compound
 * names). This allows the results of <tt>NameParser.parse()</tt> to be used as
 * arguments to the <tt>Context</tt> methods.
 * Prior to JNDI 1.2, all name arguments were treated as composite names.
 *<p>
 * Furthermore, for systems that support federation, all names returned
 * in a <tt>NamingEnumeration</tt>
 * from <tt>list()</tt> and <tt>listBindings()</tt> are composite names
 * represented as strings.
 * See <tt>CompositeName</tt> for the string syntax of names.
 *<p>
 * For systems that do not support federation, the name arguments (in
 * either <tt>Name</tt> or <tt>String</tt> forms) and the names returned in
 * <tt>NamingEnumeration</tt> may be names in their own namespace rather than
 * names in a composite namespace, at the discretion of the service
 * provider.
 *
 *<h1>Exceptions</h1>
 * All the methods in this interface can throw a <tt>NamingException</tt> or
 * any of its subclasses. See <tt>NamingException</tt> and their subclasses
 * for details on each exception.
 *
 *<h1>Concurrent Access</h1>
 * A Context instance is not guaranteed to be synchronized against
 * concurrent access by multiple threads.  Threads that need to access
 * a single Context instance concurrently should synchronize amongst
 * themselves and provide the necessary locking.  Multiple threads
 * each manipulating a different Context instance need not
 * synchronize.  Note that the {@link #lookup(Name) <tt>lookup</tt>}
 * method, when passed an empty name, will return a new Context instance
 * representing the same naming context.
 *<p>
 * For purposes of concurrency control,
 * a Context operation that returns a <tt>NamingEnumeration</tt> is
 * not considered to have completed while the enumeration is still in
 * use, or while any referrals generated by that operation are still
 * being followed.
 *
 *
 *<h1>Parameters</h1>
 * A <tt>Name</tt> parameter passed to any method of the
 * <tt>Context</tt> interface or one of its subinterfaces
 * will not be modified by the service provider.
 * The service provider may keep a reference to it
 * for the duration of the operation, including any enumeration of the
 * method's results and the processing of any referrals generated.
 * The caller should not modify the object during this time.
 * A <tt>Name</tt> returned by any such method is owned by the caller.
 * The caller may subsequently modify it; the service provider may not.
 *
 *
 *<h1>Environment Properties</h1>
 *<p>
 * JNDI applications need a way to communicate various preferences
 * and properties that define the environment in which naming and
 * directory services are accessed. For example, a context might
 * require specification of security credentials in order to access
 * the service. Another context might require that server configuration
 * information be supplied. These are referred to as the <em>environment</em>
 * of a context. The <tt>Context</tt> interface provides methods for
 * retrieving and updating this environment.
 *<p>
 * The environment is inherited from the parent context as
 * context methods proceed from one context to the next. Changes to
 * the environment of one context do not directly affect those
 * of other contexts.
 *<p>
 * It is implementation-dependent when environment properties are used
 * and/or verified for validity.  For example, some of the
 * security-related properties are used by service providers to "log in"
 * to the directory.  This login process might occur at the time the
 * context is created, or the first time a method is invoked on the
 * context.  When, and whether this occurs at all, is
 * implementation-dependent.  When environment properties are added or
 * removed from the context, verifying the validity of the changes is again
 * implementation-dependent. For example, verification of some properties
 * might occur at the time the change is made, or at the time the next
 * operation is performed on the context, or not at all.
 *<p>
 * Any object with a reference to a context may examine that context's
 * environment.  Sensitive information such as clear-text
 * passwords should not be stored there unless the implementation is
 * known to protect it.
 *
 *<p>
 *<a name=RESOURCEFILES></a>
 *<h1>Resource Files</h1>
 *<p>
 * To simplify the task of setting up the environment
 * required by a JNDI application,
 * application components and service providers may be distributed
 * along with <em>resource files.</em>
 * A JNDI resource file is a file in the properties file format (see
 * {@link java.util.Properties#load <tt>java.util.Properties</tt>}),
 * containing a list of key/value pairs.
 * The key is the name of the property (e.g. "java.naming.factory.object")
 * and the value is a string in the format defined
 * for that property.  Here is an example of a JNDI resource file:
 *
 * <blockquote>{@code
 * java.naming.factory.object=com.sun.jndi.ldap.AttrsToCorba:com.wiz.from.Person
 * java.naming.factory.state=com.sun.jndi.ldap.CorbaToAttrs:com.wiz.from.Person
 * java.naming.factory.control=com.sun.jndi.ldap.ResponseControlFactory
 * }</blockquote>
 *
 * The JNDI class library reads the resource files and makes the property
 * values freely available.  Thus JNDI resource files should be considered
 * to be "world readable", and sensitive information such as clear-text
 * passwords should not be stored there.
 *<p>
 * There are two kinds of JNDI resource files:
 * <em>provider</em> and <em>application</em>.
 *
 * <h2>Provider Resource Files</h2>
 *
 * Each service provider has an optional resource that lists properties
 * specific to that provider.  The name of this resource is:
 * <blockquote>
 * [<em>prefix</em>/]<tt>jndiprovider.properties</tt>
 * </blockquote>
 * where <em>prefix</em> is
 * the package name of the provider's context implementation(s),
 * with each period (".") converted to a slash ("/").
 *
 * For example, suppose a service provider defines a context
 * implementation with class name <tt>com.sun.jndi.ldap.LdapCtx</tt>.
 * The provider resource for this provider is named
 * <tt>com/sun/jndi/ldap/jndiprovider.properties</tt>.  If the class is
 * not in a package, the resource's name is simply
 * <tt>jndiprovider.properties</tt>.
 *
 * <p>
 * <a name=LISTPROPS></a>
 * Certain methods in the JNDI class library make use of the standard
 * JNDI properties that specify lists of JNDI factories:
 * <ul>
 * <li>java.naming.factory.object
 * <li>java.naming.factory.state
 * <li>java.naming.factory.control
 * <li>java.naming.factory.url.pkgs
 * </ul>
 * The JNDI library will consult the provider resource file
 * when determining the values of these properties.
 * Properties other than these may be set in the provider
 * resource file at the discretion of the service provider.
 * The service provider's documentation should clearly state which
 * properties are allowed; other properties in the file will be ignored.
 *
 * <h2>Application Resource Files</h2>
 *
 * When an application is deployed, it will generally have several
 * codebase directories and JARs in its classpath.  Similarly, when an
 * applet is deployed, it will have a codebase and archives specifying
 * where to find the applet's classes.  JNDI locates (using
 * {@link ClassLoader#getResources <tt>ClassLoader.getResources()</tt>})
 * all <em>application resource files</em> named <tt>jndi.properties</tt>
 * in the classpath.
 * In addition, if the file <i>java.home</i><tt>/lib/jndi.properties</tt>
 * exists and is readable,
 * JNDI treats it as an additional application resource file.
 * (<i>java.home</i> indicates the
 * directory named by the <tt>java.home</tt> system property.)
 * All of the properties contained in these files are placed
 * into the environment of the initial context.  This environment
 * is then inherited by other contexts.
 *
 * <p>
 * For each property found in more than one application resource file,
 * JNDI uses the first value found or, in a few cases where it makes
 * sense to do so, it concatenates all of the values (details are given
 * below).
 * For example, if the "java.naming.factory.object" property is found in
 * three <tt>jndi.properties</tt> resource files, the
 * list of object factories is a concatenation of the property
 * values from all three files.
 * Using this scheme, each deployable component is responsible for
 * listing the factories that it exports.  JNDI automatically
 * collects and uses all of these export lists when searching for factory
 * classes.
 *
 * <h2>Search Algorithm for Properties</h2>
 *
 * When JNDI constructs an initial context, the context's environment
 * is initialized with properties defined in the environment parameter
 * passed to the constructor, the system properties, the applet parameters,
 * and the application resource files.  See
 * <a href=InitialContext.html#ENVIRONMENT><tt>InitialContext</tt></a>
 * for details.
 * This initial environment is then inherited by other context instances.
 *
 * <p>
 * When the JNDI class library needs to determine
 * the value of a property, it does so by merging
 * the values from the following two sources, in order:
 * <ol>
 * <li>The environment of the context being operated on.
 * <li>The provider resource file (<tt>jndiprovider.properties</tt>)
 * for the context being operated on.
 * </ol>
 * For each property found in both of these two sources,
 * JNDI determines the property's value as follows.  If the property is
 * one of the standard JNDI properties that specify a list of JNDI
 * factories (listed <a href=#LISTPROPS>above</a>), the values are
 * concatenated into a single colon-separated list.  For other
 * properties, only the first value found is used.
 *
 * <p>
 * When a service provider needs to determine the value of a property,
 * it will generally take that value directly from the environment.
 * A service provider may define provider-specific properties
 * to be placed in its own provider resource file.  In that
 * case it should merge values as described in the previous paragraph.
 *
 * <p>
 * In this way, each service provider developer can specify a list of
 * factories to use with that service provider. These can be modified by
 * the application resources specified by the deployer of the application
 * or applet, which in turn can be modified by the user.
 *
 * <p>
 *  此接口表示命名上下文,其由一组名称到对象绑定组成。它包含用于检查和更新这些绑定的方法。
 * 
 *  <h1>名称</h1>作为参数传递给<tt>上下文</tt>方法的每个名称都与该上下文相关。空名称用于命名上下文本身。 name参数永远不能为null。
 * <p>
 *  大多数方法具有重载版本,其中一个采用<code> Name </code>参数,一个采用<code> String </code>。
 * 这些重载的版本是等同的,如果<code> Name </code>和<code> String </code>参数只是同一个名称的不同表示,那么相同方法的重载版本行为相同。
 * 在下面的方法描述中,只有一个版本完整记录。第二个版本有一个链接到第一个：同样的文档适用于两者。
 * <p>
 * 对于支持联合的系统,<tt>上下文</tt>方法的<tt> String </tt>名称参数是复合名称。
 * 作为<tt> CompositeName </tt>实例的名称参数被视为复合名称,而不是<tt> CompositeName </tt>实例的<tt> Name </tt>参数被视为复合名称可能是<tt>
 *  CompoundName </tt>或化合物名称的其他实现的实例)。
 * 对于支持联合的系统,<tt>上下文</tt>方法的<tt> String </tt>名称参数是复合名称。
 * 这允许将<tt> NameParser.parse()</tt>的结果用作<tt>上下文</tt>方法的参数。在JNDI 1.2之前,所有名称参数都被视为复合名称。
 * p>
 *  此外,对于支持联合的系统,从<tt> list()</tt>和<tt> listBindings()</tt>中的<tt> NamingEnumeration </tt>中返回的所有名称都是以字符串表
 * 示的复合名称。
 * 有关名称的字符串语法,请参见<tt> CompositeName </tt>。
 * p>
 *  对于不支持联合的系统,名称参数(<tt> Name </tt>或<tt> String </tt>表单)和<tt> NamingEnumeration </tt>中返回的名称可能是它们自己的命名空间而
 * 不是复合命名空间中的名称,由服务提供商自行决定。
 * 
 *  h1>异常</h1>此界面中的所有方法都可以抛出一个<tt> NamingException </tt>或其任何子类。
 * 有关每个异常的详细信息,请参见<tt> NamingException </tt>及其子类。
 * 
 * h1>并发访问</h1>不能保证上下文实例与多个线程的并发访问同步。需要并发访问单个Context实例的线程应在它们之间同步并提供必要的锁定。每个操作不同的Context实例的多个线程不需要同步。
 * 请注意,{@link #lookup(Name)<tt> lookup </tt>}方法传递一个空名称时,将返回一个代表相同命名上下文的新Context实例。
 * p>
 *  为了并发控制的目的,返回<tt> NamingEnumeration </tt>的上下文操作在枚举仍在使用中时,或者当该操作生成的任何引用仍被遵循时,不被认为已经完成。
 * 
 *  h1>参数</h1>传递给<tt> Context </tt>接口的任何方法或其子接口之一的<tt> Name </tt>参数不会被服务提供程序修改。
 * 服务提供商可以在操作的持续时间保持对其的引用,包括方法的结果的任何枚举以及生成的任何引用的处理。调用者在此期间不应该修改对象。由任何此类方法返回的<tt>名称</tt>由调用者拥有。
 * 调用者可以随后修改它;服务提供商可能不会。
 * 
 *  h1>环境属性</h1>
 * p>
 * JNDI应用程序需要一种方法来传递定义访问命名和目录服务的环境的各种首选项和属性。例如,上下文可能需要指定安全凭证才能访问服务。另一个上下文可能需要提供服务器配置信息。
 * 这些被称为上下文的<em>环境</em>。 <tt>上下文</tt>界面提供检索和更新此环境的方法。
 * p>
 *  当上下文方法从一个上下文继续到下一个上下文时,环境从父上下文继承。对一个上下文的环境的改变不直接影响其他上下文的环境。
 * p>
 *  当使用和/或验证环境属性的有效性时,它是实现相关的。例如,服务提供商使用一些与安全相关的属性来"登录"到目录。此登录过程可能在创建上下文时或在上下文上第一次调用方法时发生。
 * 何时,以及这是否发生,是实现依赖的。当从上下文添加或删除环境属性时,验证更改的有效性也是实现相关的。例如,一些属性的验证可以在进行改变时或在对上下文执行下一操作时发生,或者根本不发生。
 * p>
 * 任何具有上下文引用的对象都可以检查该上下文的环境。敏感信息(例如明文密码)不应存储在那里,除非已知实施可保护敏感信息。
 * 
 * p>
 *  a name = RESOURCEFILES> </a> h1>资源文件</h1>
 * p>
 *  为了简化设置JNDI应用所需的环境的任务,应用组件和服务提供者可以与资源文件一起分布。
 * </em> JNDI资源文件是属性文件格式的文件(参见{ @link java.util.Properties#load <tt> java.util.Properties </tt>}),其中包含键/
 * 值对列表。
 *  为了简化设置JNDI应用所需的环境的任务,应用组件和服务提供者可以与资源文件一起分布。键是属性的名称(例如"java.naming.factory.object"),值是以该属性定义的格式的字符串。
 * 下面是一个JNDI资源文件的示例：。
 * 
 *  <blockquote> {@ code java.naming.factory.object = com.sun.jndi.ldap.AttrsToCorba：com.wiz.from.Person java.naming.factory.state = com.sun.jndi.ldap.CorbaToAttrs：com .wiz.from.Person java.naming.factory.control = com.sun.jndi.ldap.ResponseControlFactory}
 *  </blockquote>。
 * 
 *  JNDI类库读取资源文件,并使属性值免费提供。因此,JNDI资源文件应被视为"世界可读",并且敏感信息(如明文密码)不应存储在那里。
 * p>
 *  有两种JNDI资源文件：<em> provider </em>和<em> application </em>。
 * 
 *  <h2>提供程序资源文件</h2>
 * 
 * 每个服务提供程序都有一个可选的资源,列出特定于该提供程序的属性。此资源的名称为：
 * <blockquote>
 *  [<em>前缀</em> /] <tt> jndiprovider.properties </tt>
 * </blockquote>
 *  其中<em>前缀</em>是提供商的上下文实现的包名称,每个句点("。")转换为斜杠("/")。
 * 
 *  例如,假设服务提供者定义类名为<tt> com.sun.jndi.ldap.LdapCtx </tt>的上下文实现。
 * 此提供程序的提供程序资源名为<tt> com / sun / jndi / ldap / jndiprovider.properties </tt>。
 * 如果类不在包中,则资源的名称只是<tt> jndiprovider.properties </tt>。
 * 
 * <p>
 *  <a name=LISTPROPS> </a> JNDI类库中的某些方法使用指定JNDI工厂列表的标准JNDI属性：
 * <ul>
 *  <li> java.naming.factory.object <li> java.naming.factory.state <li> java.naming.factory.control <li>
 *  java.naming.factory.url.pkgs。
 * </ul>
 *  确定这些属性的值时,JNDI库将查询提供程序资源文件。除了这些之外的属性可以由服务提供商自行决定在提供者资源文件中设置。服务提供者的文档应该清楚地说明允许哪些属性;文件中的其他属性将被忽略。
 * 
 *  <h2>应用程序资源文件</h2>
 * 
 * 部署应用程序时,它通常在其类路径中具有多个代码库目录和JAR。类似地,当部署applet时,它将具有指定在哪里找到applet的类的代码库和存档。
 *  JNDI在类路径中定位(使用{@link ClassLoader#getResources <tt> ClassLoader.getResources()</tt>})所有<em>应用程序资源文件</em>
 * ,名称为<tt> jndi.properties </tt>。
 * 部署应用程序时,它通常在其类路径中具有多个代码库目录和JAR。类似地,当部署applet时,它将具有指定在哪里找到applet的类的代码库和存档。
 * 此外,如果文件<i> java.home </i> <tt> /lib/jndi.properties </tt>存在并且可读,则JNDI将其视为另一个应用程序资源文件。
 *  (<i> java.home </i>指示由<tt> java.home </tt>系统属性命名的目录。)这些文件中包含的所有属性都放置在初始上下文的环境中。这个环境然后由其他上下文继承。
 * 
 * <p>
 *  对于在多个应用程序资源文件中找到的每个属性,JNDI使用找到的第一个值,或者在有些情况下这样做有意义,它会连接所有值(详细信息如下)。
 * 例如,如果在三个<tt> jndi.properties </tt>资源文件中找到"java.naming.factory.object"属性,则对象工厂的列表是来自所有三个文件的属性值的并置。
 * 使用此方案,每个可部署组件负责列出其导出的工厂。 JNDI在搜索工厂类时自动收集和使用所有这些导出列表。
 * 
 *  <h2>属性的搜索算法</h2>
 * 
 * 当JNDI构造初始上下文时,使用传递给构造函数的环境参数中定义的属性,系统属性,小程序参数和应用程序资源文件来初始化上下文的环境。
 * 有关详细信息,请参见<a href=InitialContext.html#ENVIRONMENT> <tt> InitialContext </tt> </a>。
 * 然后,这个初始环境被其他上下文实例继承。
 * 
 * <p>
 *  当JNDI类库需要确定属性的值时,它通过按顺序合并来自以下两个源的值来实现：
 * <ol>
 *  <li>正在操作的上下文的环境。 <li>正在操作的上下文的提供程序资源文件(<tt> jndiprovider.properties </tt>)。
 * </ol>
 *  对于在这两个源中找到的每个属性,JNDI如下确定属性的值。
 * 如果属性是指定JNDI工厂列表(列出为<a href=#LISTPROPS>上述</a>)的标准JNDI属性之一,则值将连接到单个以冒号分隔的列表中。对于其他属性,只使用找到的第一个值。
 * 
 * <p>
 *  当服务提供商需要确定属性的值时,它通常直接从环境中获取该值。服务提供者可以定义要放置在其自己的提供者资源文件中的特定于提供者的属性。在这种情况下,它应该如上一段所述合并值。
 * 
 * <p>
 * 以这种方式,每个服务提供商开发者可以指定要与该服务提供商一起使用的工厂的列表。这些可以由应用程序或小程序的部署者指定的应用程序资源来修改,而应用程序或小程序的部署者又可以由用户修改。
 * 
 * 
 * @author Rosanna Lee
 * @author Scott Seligman
 * @author R. Vasudevan
 *
 * @since 1.3
 */

public interface Context {

    /**
     * Retrieves the named object.
     * If <tt>name</tt> is empty, returns a new instance of this context
     * (which represents the same naming context as this context, but its
     * environment may be modified independently and it may be accessed
     * concurrently).
     *
     * <p>
     *  检索命名对象。如果<tt> name </tt>为空,则返回此上下文的新实例(代表与此上下文相同的命名上下文,但其环境可以单独修改,并且可以同时访问)。
     * 
     * 
     * @param name
     *          the name of the object to look up
     * @return  the object bound to <tt>name</tt>
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #lookup(String)
     * @see #lookupLink(Name)
     */
    public Object lookup(Name name) throws NamingException;

    /**
     * Retrieves the named object.
     * See {@link #lookup(Name)} for details.
     * <p>
     *  检索命名对象。有关详情,请参阅{@link #lookup(Name)}。
     * 
     * 
     * @param name
     *          the name of the object to look up
     * @return  the object bound to <tt>name</tt>
     * @throws  NamingException if a naming exception is encountered
     */
    public Object lookup(String name) throws NamingException;

    /**
     * Binds a name to an object.
     * All intermediate contexts and the target context (that named by all
     * but terminal atomic component of the name) must already exist.
     *
     * <p>
     *  为对象绑定名称。所有中间上下文和目标上下文(由名称的终端原子组件除外的所有中间上下文和目标上下文)必须已经存在。
     * 
     * 
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #bind(String, Object)
     * @see #rebind(Name, Object)
     * @see javax.naming.directory.DirContext#bind(Name, Object,
     *          javax.naming.directory.Attributes)
     */
    public void bind(Name name, Object obj) throws NamingException;

    /**
     * Binds a name to an object.
     * See {@link #bind(Name, Object)} for details.
     *
     * <p>
     *  为对象绑定名称。有关详细信息,请参阅{@link #bind(Name,Object)}。
     * 
     * 
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     */
    public void bind(String name, Object obj) throws NamingException;

    /**
     * Binds a name to an object, overwriting any existing binding.
     * All intermediate contexts and the target context (that named by all
     * but terminal atomic component of the name) must already exist.
     *
     * <p> If the object is a <tt>DirContext</tt>, any existing attributes
     * associated with the name are replaced with those of the object.
     * Otherwise, any existing attributes associated with the name remain
     * unchanged.
     *
     * <p>
     *  将名称绑定到对象,覆盖任何现有绑定。所有中间上下文和目标上下文(由名称的终端原子组件除外的所有中间上下文和目标上下文)必须已经存在。
     * 
     *  <p>如果对象是<tt> DirContext </tt>,则与名称关联的任何现有属性都将替换为对象的名称。否则,与名称关联的任何现有属性保持不变。
     * 
     * 
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #rebind(String, Object)
     * @see #bind(Name, Object)
     * @see javax.naming.directory.DirContext#rebind(Name, Object,
     *          javax.naming.directory.Attributes)
     * @see javax.naming.directory.DirContext
     */
    public void rebind(Name name, Object obj) throws NamingException;

    /**
     * Binds a name to an object, overwriting any existing binding.
     * See {@link #rebind(Name, Object)} for details.
     *
     * <p>
     *  将名称绑定到对象,覆盖任何现有绑定。有关详细信息,请参阅{@link #rebind(Name,Object)}。
     * 
     * 
     * @param name
     *          the name to bind; may not be empty
     * @param obj
     *          the object to bind; possibly null
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if object did not supply all mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     */
    public void rebind(String name, Object obj) throws NamingException;

    /**
     * Unbinds the named object.
     * Removes the terminal atomic name in <code>name</code>
     * from the target context--that named by all but the terminal
     * atomic part of <code>name</code>.
     *
     * <p> This method is idempotent.
     * It succeeds even if the terminal atomic name
     * is not bound in the target context, but throws
     * <tt>NameNotFoundException</tt>
     * if any of the intermediate contexts do not exist.
     *
     * <p> Any attributes associated with the name are removed.
     * Intermediate contexts are not changed.
     *
     * <p>
     *  取消绑定命名对象。从目标上下文中删除<code> name </code>中的终端原子名称 - 除了<code> name </code>的终端原子部分,所有终止原子名称。
     * 
     * <p>此方法是幂等的。即使终端原子名未在目标上下文中绑定,也会成功,但如果任何中间上下文不存在,则会抛出<tt> NameNotFoundException </tt>。
     * 
     *  <p>与名称关联的任何属性都将被删除。中间上下文不更改。
     * 
     * 
     * @param name
     *          the name to unbind; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NamingException if a naming exception is encountered
     * @see #unbind(String)
     */
    public void unbind(Name name) throws NamingException;

    /**
     * Unbinds the named object.
     * See {@link #unbind(Name)} for details.
     *
     * <p>
     *  取消绑定命名对象。有关详细信息,请参阅{@link #unbind(Name)}。
     * 
     * 
     * @param name
     *          the name to unbind; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NamingException if a naming exception is encountered
     */
    public void unbind(String name) throws NamingException;

    /**
     * Binds a new name to the object bound to an old name, and unbinds
     * the old name.  Both names are relative to this context.
     * Any attributes associated with the old name become associated
     * with the new name.
     * Intermediate contexts of the old name are not changed.
     *
     * <p>
     *  为绑定到旧名称的对象绑定一个新名称,并解除绑定旧名称。这两个名称都与此上下文相关。与旧名称关联的任何属性都将与新名称关联。旧名称的中间上下文不会更改。
     * 
     * 
     * @param oldName
     *          the name of the existing binding; may not be empty
     * @param newName
     *          the name of the new binding; may not be empty
     * @throws  NameAlreadyBoundException if <tt>newName</tt> is already bound
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #rename(String, String)
     * @see #bind(Name, Object)
     * @see #rebind(Name, Object)
     */
    public void rename(Name oldName, Name newName) throws NamingException;

    /**
     * Binds a new name to the object bound to an old name, and unbinds
     * the old name.
     * See {@link #rename(Name, Name)} for details.
     *
     * <p>
     *  为绑定到旧名称的对象绑定一个新名称,并解除绑定旧名称。有关详细信息,请参阅{@link #rename(Name,Name)}。
     * 
     * 
     * @param oldName
     *          the name of the existing binding; may not be empty
     * @param newName
     *          the name of the new binding; may not be empty
     * @throws  NameAlreadyBoundException if <tt>newName</tt> is already bound
     * @throws  NamingException if a naming exception is encountered
     */
    public void rename(String oldName, String newName) throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * class names of objects bound to them.
     * The contents of any subcontexts are not included.
     *
     * <p> If a binding is added to or removed from this context,
     * its effect on an enumeration previously returned is undefined.
     *
     * <p>
     *  枚举在命名上下文中绑定的名称,以及绑定到它们的对象的类名。不包括任何子上下文的内容。
     * 
     *  <p>如果向此上下文添加或删除绑定,则对先前返回的枚举的影响未定义。
     * 
     * 
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the names and class names of the
     *          bindings in this context.  Each element of the
     *          enumeration is of type <tt>NameClassPair</tt>.
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #list(String)
     * @see #listBindings(Name)
     * @see NameClassPair
     */
    public NamingEnumeration<NameClassPair> list(Name name)
        throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * class names of objects bound to them.
     * See {@link #list(Name)} for details.
     *
     * <p>
     *  枚举在命名上下文中绑定的名称,以及绑定到它们的对象的类名。有关详细信息,请参阅{@link #list(Name)}。
     * 
     * 
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the names and class names of the
     *          bindings in this context.  Each element of the
     *          enumeration is of type <tt>NameClassPair</tt>.
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration<NameClassPair> list(String name)
        throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * objects bound to them.
     * The contents of any subcontexts are not included.
     *
     * <p> If a binding is added to or removed from this context,
     * its effect on an enumeration previously returned is undefined.
     *
     * <p>
     *  枚举在命名上下文中绑定的名称以及绑定到它们的对象。不包括任何子上下文的内容。
     * 
     *  <p>如果向此上下文添加或删除绑定,则对先前返回的枚举的影响未定义。
     * 
     * 
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the bindings in this context.
     *          Each element of the enumeration is of type
     *          <tt>Binding</tt>.
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #listBindings(String)
     * @see #list(Name)
     * @see Binding
      */
    public NamingEnumeration<Binding> listBindings(Name name)
        throws NamingException;

    /**
     * Enumerates the names bound in the named context, along with the
     * objects bound to them.
     * See {@link #listBindings(Name)} for details.
     *
     * <p>
     * 枚举在命名上下文中绑定的名称以及绑定到它们的对象。有关详情,请参阅{@link #listBindings(Name)}。
     * 
     * 
     * @param name
     *          the name of the context to list
     * @return  an enumeration of the bindings in this context.
     *          Each element of the enumeration is of type
     *          <tt>Binding</tt>.
     * @throws  NamingException if a naming exception is encountered
     */
    public NamingEnumeration<Binding> listBindings(String name)
        throws NamingException;

    /**
     * Destroys the named context and removes it from the namespace.
     * Any attributes associated with the name are also removed.
     * Intermediate contexts are not destroyed.
     *
     * <p> This method is idempotent.
     * It succeeds even if the terminal atomic name
     * is not bound in the target context, but throws
     * <tt>NameNotFoundException</tt>
     * if any of the intermediate contexts do not exist.
     *
     * <p> In a federated naming system, a context from one naming system
     * may be bound to a name in another.  One can subsequently
     * look up and perform operations on the foreign context using a
     * composite name.  However, an attempt destroy the context using
     * this composite name will fail with
     * <tt>NotContextException</tt>, because the foreign context is not
     * a "subcontext" of the context in which it is bound.
     * Instead, use <tt>unbind()</tt> to remove the
     * binding of the foreign context.  Destroying the foreign context
     * requires that the <tt>destroySubcontext()</tt> be performed
     * on a context from the foreign context's "native" naming system.
     *
     * <p>
     *  销毁命名上下文并将其从命名空间中删除。与名称关联的任何属性也将被删除。中间上下文不会被销毁。
     * 
     *  <p>此方法是幂等的。即使终端原子名未在目标上下文中绑定,也会成功,但如果任何中间上下文不存在,则会抛出<tt> NameNotFoundException </tt>。
     * 
     *  <p>在联合命名系统中,来自一个命名系统的上下文可能绑定到另一个命名系统中的名称。随后可以使用复合名称查找并对外部上下文执行操作。
     * 但是,尝试使用此复合名称破坏上下文将失败,并且<tt> NotContextException </tt>,因为外部上下文不是其绑定的上下文的"子上下文"。
     * 而应使用<tt> unbind()</tt>删除外部上下文的绑定。破坏外部上下文需要对来自外部上下文的"本地"命名系统的上下文执行<tt> destroySubcontext()</tt>。
     * 
     * 
     * @param name
     *          the name of the context to be destroyed; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NotContextException if the name is bound but does not name a
     *          context, or does not name a context of the appropriate type
     * @throws  ContextNotEmptyException if the named context is not empty
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #destroySubcontext(String)
     */
    public void destroySubcontext(Name name) throws NamingException;

    /**
     * Destroys the named context and removes it from the namespace.
     * See {@link #destroySubcontext(Name)} for details.
     *
     * <p>
     *  销毁命名上下文并将其从命名空间中删除。有关详情,请参阅{@link #destroySubcontext(Name)}。
     * 
     * 
     * @param name
     *          the name of the context to be destroyed; may not be empty
     * @throws  NameNotFoundException if an intermediate context does not exist
     * @throws  NotContextException if the name is bound but does not name a
     *          context, or does not name a context of the appropriate type
     * @throws  ContextNotEmptyException if the named context is not empty
     * @throws  NamingException if a naming exception is encountered
     */
    public void destroySubcontext(String name) throws NamingException;

    /**
     * Creates and binds a new context.
     * Creates a new context with the given name and binds it in
     * the target context (that named by all but terminal atomic
     * component of the name).  All intermediate contexts and the
     * target context must already exist.
     *
     * <p>
     *  创建和绑定新的上下文。创建具有给定名称的新上下文,并将其绑定在目标上下文中(由名称的所有终端原子组件命名的)。所有中间上下文和目标上下文必须已经存在。
     * 
     * 
     * @param name
     *          the name of the context to create; may not be empty
     * @return  the newly created context
     *
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if creation of the subcontext requires specification of
     *          mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #createSubcontext(String)
     * @see javax.naming.directory.DirContext#createSubcontext
     */
    public Context createSubcontext(Name name) throws NamingException;

    /**
     * Creates and binds a new context.
     * See {@link #createSubcontext(Name)} for details.
     *
     * <p>
     * 创建和绑定新的上下文。有关详情,请参阅{@link #createSubcontext(Name)}。
     * 
     * 
     * @param name
     *          the name of the context to create; may not be empty
     * @return  the newly created context
     *
     * @throws  NameAlreadyBoundException if name is already bound
     * @throws  javax.naming.directory.InvalidAttributesException
     *          if creation of the subcontext requires specification of
     *          mandatory attributes
     * @throws  NamingException if a naming exception is encountered
     */
    public Context createSubcontext(String name) throws NamingException;

    /**
     * Retrieves the named object, following links except
     * for the terminal atomic component of the name.
     * If the object bound to <tt>name</tt> is not a link,
     * returns the object itself.
     *
     * <p>
     *  检索命名对象,除了名称的终端原子组件之外的链接。如果绑定到<tt>名称</tt>的对象不是链接,则返回对象本身。
     * 
     * 
     * @param name
     *          the name of the object to look up
     * @return  the object bound to <tt>name</tt>, not following the
     *          terminal link (if any).
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #lookupLink(String)
     */
    public Object lookupLink(Name name) throws NamingException;

    /**
     * Retrieves the named object, following links except
     * for the terminal atomic component of the name.
     * See {@link #lookupLink(Name)} for details.
     *
     * <p>
     *  检索命名对象,除了名称的终端原子组件之外的链接。有关详细信息,请参阅{@link #lookupLink(Name)}。
     * 
     * 
     * @param name
     *          the name of the object to look up
     * @return  the object bound to <tt>name</tt>, not following the
     *          terminal link (if any)
     * @throws  NamingException if a naming exception is encountered
     */
    public Object lookupLink(String name) throws NamingException;

    /**
     * Retrieves the parser associated with the named context.
     * In a federation of namespaces, different naming systems will
     * parse names differently.  This method allows an application
     * to get a parser for parsing names into their atomic components
     * using the naming convention of a particular naming system.
     * Within any single naming system, <tt>NameParser</tt> objects
     * returned by this method must be equal (using the <tt>equals()</tt>
     * test).
     *
     * <p>
     *  检索与命名上下文关联的解析器。在命名空间的联合中,不同的命名系统将以不同的方式解析名称。此方法允许应用程序获得解析器,用于使用特定命名系统的命名约定将名称解析为其原子组件。
     * 在任何单个命名系统中,此方法返回的<tt> NameParser </tt>对象必须相等(使用<tt> equals()</tt>测试)。
     * 
     * 
     * @param name
     *          the name of the context from which to get the parser
     * @return  a name parser that can parse compound names into their atomic
     *          components
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getNameParser(String)
     * @see CompoundName
     */
    public NameParser getNameParser(Name name) throws NamingException;

    /**
     * Retrieves the parser associated with the named context.
     * See {@link #getNameParser(Name)} for details.
     *
     * <p>
     *  检索与命名上下文关联的解析器。有关详情,请参阅{@link #getNameParser(Name)}。
     * 
     * 
     * @param name
     *          the name of the context from which to get the parser
     * @return  a name parser that can parse compound names into their atomic
     *          components
     * @throws  NamingException if a naming exception is encountered
     */
    public NameParser getNameParser(String name) throws NamingException;

    /**
     * Composes the name of this context with a name relative to
     * this context.
     * Given a name (<code>name</code>) relative to this context, and
     * the name (<code>prefix</code>) of this context relative to one
     * of its ancestors, this method returns the composition of the
     * two names using the syntax appropriate for the naming
     * system(s) involved.  That is, if <code>name</code> names an
     * object relative to this context, the result is the name of the
     * same object, but relative to the ancestor context.  None of the
     * names may be null.
     * <p>
     * For example, if this context is named "wiz.com" relative
     * to the initial context, then
     * <pre>
     *  composeName("east", "wiz.com")  </pre>
     * might return <code>"east.wiz.com"</code>.
     * If instead this context is named "org/research", then
     * <pre>
     *  composeName("user/jane", "org/research")        </pre>
     * might return <code>"org/research/user/jane"</code> while
     * <pre>
     *  composeName("user/jane", "research")    </pre>
     * returns <code>"research/user/jane"</code>.
     *
     * <p>
     *  使用相对于此上下文的名称构造此上下文的名称。
     * 给定相对于该上下文的名称(<code> name </code>)以及该上下文相对于其上一个祖先的名称(<code>前缀</code>),该方法返回两个名称的组合使用适用于所涉及的命名系统的语法。
     * 也就是说,如果<code> name </code>命名了一个与这个上下文相关的对象,结果就是同一个对象的名称,但是相对于祖先上下文。所有名称都不能为空。
     * <p>
     * 例如,如果此上下文相对于初始上下文命名为"wiz.com",则
     * <pre>
     *  composeName("east","wiz.com")</pre>可能会返回<code>"east.wiz.com"</code>。
     * 如果相反,这个上下文被命名为"org / research",那么。
     * <pre>
     *  composeName("user / jane","org / research")</pre>可能会返回<code>"org / research / user / jane"</code>
     * <pre>
     *  composeName("user / jane","research")</pre>返回<code>"research / user / jane"</code>。
     * 
     * 
     * @param name
     *          a name relative to this context
     * @param prefix
     *          the name of this context relative to one of its ancestors
     * @return  the composition of <code>prefix</code> and <code>name</code>
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #composeName(String, String)
     */
    public Name composeName(Name name, Name prefix)
        throws NamingException;

    /**
     * Composes the name of this context with a name relative to
     * this context.
     * See {@link #composeName(Name, Name)} for details.
     *
     * <p>
     *  使用相对于此上下文的名称构造此上下文的名称。有关详情,请参阅{@link #composeName(Name,Name)}。
     * 
     * 
     * @param name
     *          a name relative to this context
     * @param prefix
     *          the name of this context relative to one of its ancestors
     * @return  the composition of <code>prefix</code> and <code>name</code>
     * @throws  NamingException if a naming exception is encountered
     */
    public String composeName(String name, String prefix)
            throws NamingException;

    /**
     * Adds a new environment property to the environment of this
     * context.  If the property already exists, its value is overwritten.
     * See class description for more details on environment properties.
     *
     * <p>
     *  向此上下文的环境中添加新的环境属性。如果属性已存在,则其值将被覆盖。有关环境属性的更多详细信息,请参阅类描述。
     * 
     * 
     * @param propName
     *          the name of the environment property to add; may not be null
     * @param propVal
     *          the value of the property to add; may not be null
     * @return  the previous value of the property, or null if the property was
     *          not in the environment before
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getEnvironment()
     * @see #removeFromEnvironment(String)
     */
    public Object addToEnvironment(String propName, Object propVal)
        throws NamingException;

    /**
     * Removes an environment property from the environment of this
     * context.  See class description for more details on environment
     * properties.
     *
     * <p>
     *  从此上下文的环境中删除环境属性。有关环境属性的更多详细信息,请参阅类描述。
     * 
     * 
     * @param propName
     *          the name of the environment property to remove; may not be null
     * @return  the previous value of the property, or null if the property was
     *          not in the environment
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #getEnvironment()
     * @see #addToEnvironment(String, Object)
     */
    public Object removeFromEnvironment(String propName)
        throws NamingException;

    /**
     * Retrieves the environment in effect for this context.
     * See class description for more details on environment properties.
     *
     * <p> The caller should not make any changes to the object returned:
     * their effect on the context is undefined.
     * The environment of this context may be changed using
     * <tt>addToEnvironment()</tt> and <tt>removeFromEnvironment()</tt>.
     *
     * <p>
     *  检索在此上下文中有效的环境。有关环境属性的更多详细信息,请参阅类描述。
     * 
     *  <p>调用者不应该对返回的对象进行任何更改：它们对上下文的影响是未定义的。
     * 可以使用<tt> addToEnvironment()</tt>和<tt> removeFromEnvironment()</tt>更改此上下文的环境。
     * 
     * 
     * @return  the environment of this context; never null
     * @throws  NamingException if a naming exception is encountered
     *
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    public Hashtable<?,?> getEnvironment() throws NamingException;

    /**
     * Closes this context.
     * This method releases this context's resources immediately, instead of
     * waiting for them to be released automatically by the garbage collector.
     *
     * <p> This method is idempotent:  invoking it on a context that has
     * already been closed has no effect.  Invoking any other method
     * on a closed context is not allowed, and results in undefined behaviour.
     *
     * <p>
     *  关闭此上下文。此方法立即释放此上下文的资源,而不是等待它们由垃圾回收器自动释放。
     * 
     * <p>此方法是幂等的：在已经关闭的上下文上调用它不起作用。不允许在封闭上下文上调用任何其他方法,并导致未定义的行为。
     * 
     * 
     * @throws  NamingException if a naming exception is encountered
     */
    public void close() throws NamingException;

    /**
     * Retrieves the full name of this context within its own namespace.
     *
     * <p> Many naming services have a notion of a "full name" for objects
     * in their respective namespaces.  For example, an LDAP entry has
     * a distinguished name, and a DNS record has a fully qualified name.
     * This method allows the client application to retrieve this name.
     * The string returned by this method is not a JNDI composite name
     * and should not be passed directly to context methods.
     * In naming systems for which the notion of full name does not
     * make sense, <tt>OperationNotSupportedException</tt> is thrown.
     *
     * <p>
     *  在其自己的命名空间中检索此上下文的全名。
     * 
     *  <p>许多命名服务在其各自的命名空间中具有对象的"全名"概念。例如,LDAP条目具有专有名称,并且DNS记录具有完全限定名称。此方法允许客户端应用程序检索此名称。
     * 此方法返回的字符串不是JNDI复合名称,不应直接传递给上下文方法。在命名系统中,全名的概念没有意义,则会抛出<tt> OperationNotSupportedException </tt>。
     * 
     * 
     * @return  this context's name in its own namespace; never null
     * @throws  OperationNotSupportedException if the naming system does
     *          not have the notion of a full name
     * @throws  NamingException if a naming exception is encountered
     *
     * @since 1.3
     */
    public String getNameInNamespace() throws NamingException;

// public static final:  JLS says recommended style is to omit these modifiers
// because they are the default

    /**
     * Constant that holds the name of the environment property
     * for specifying the initial context factory to use. The value
     * of the property should be the fully qualified class name
     * of the factory class that will create an initial context.
     * This property may be specified in the environment parameter
     * passed to the initial context constructor, an applet parameter,
     * a system property, or an application resource file.
     * If it is not specified in any of these sources,
     * <tt>NoInitialContextException</tt> is thrown when an initial
     * context is required to complete an operation.
     *
     * <p> The value of this constant is "java.naming.factory.initial".
     *
     * <p>
     *  包含用于指定要使用的初始上下文工厂的environment属性的名称的常量。属性的值应该是将创建初始上下文的工厂类的完全限定类名。
     * 此属性可以在传递给初始上下文构造函数的环境参数中指定,applet参数,系统属性或应用程序资源文件。
     * 如果未在任何这些源中指定,则在需要初始上下文以完成操作时,会抛出<tt> NoInitialContextException </tt>。
     * 
     *  <p>此常量的值为"java.naming.factory.initial"。
     * 
     * 
     * @see InitialContext
     * @see javax.naming.directory.InitialDirContext
     * @see javax.naming.spi.NamingManager#getInitialContext
     * @see javax.naming.spi.InitialContextFactory
     * @see NoInitialContextException
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     */
    String INITIAL_CONTEXT_FACTORY = "java.naming.factory.initial";

    /**
     * Constant that holds the name of the environment property
     * for specifying the list of object factories to use. The value
     * of the property should be a colon-separated list of the fully
     * qualified class names of factory classes that will create an object
     * given information about the object.
     * This property may be specified in the environment, an applet
     * parameter, a system property, or one or more resource files.
     *
     * <p> The value of this constant is "java.naming.factory.object".
     *
     * <p>
     * 包含用于指定要使用的对象工厂的列表的environment属性的名称的常量。属性的值应该是以冒号分隔的工厂类的完全限定类名的列表,这将创建一个给定关于对象的信息的对象。
     * 可以在环境中指定此属性,小程序参数,系统属性或一个或多个资源文件。
     * 
     *  <p>此常量的值为"java.naming.factory.object"。
     * 
     * 
     * @see javax.naming.spi.NamingManager#getObjectInstance
     * @see javax.naming.spi.ObjectFactory
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     */
    String OBJECT_FACTORIES = "java.naming.factory.object";

    /**
     * Constant that holds the name of the environment property
     * for specifying the list of state factories to use. The value
     * of the property should be a colon-separated list of the fully
     * qualified class names of state factory classes that will be used
     * to get an object's state given the object itself.
     * This property may be specified in the environment, an applet
     * parameter, a system property, or one or more resource files.
     *
     * <p> The value of this constant is "java.naming.factory.state".
     *
     * <p>
     *  包含用于指定要使用的状态工厂列表的environment属性的名称的常量。属性的值应该是以冒号分隔的状态工厂类的完全限定类名的列表,将用于获取对象本身的对象状态。
     * 可以在环境中指定此属性,小程序参数,系统属性或一个或多个资源文件。
     * 
     *  <p>此常量的值为"java.naming.factory.state"。
     * 
     * 
     * @see javax.naming.spi.NamingManager#getStateToBind
     * @see javax.naming.spi.StateFactory
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     * @since 1.3
     */
    String STATE_FACTORIES = "java.naming.factory.state";

    /**
     * Constant that holds the name of the environment property
     * for specifying the list of package prefixes to use when
     * loading in URL context factories. The value
     * of the property should be a colon-separated list of package
     * prefixes for the class name of the factory class that will create
     * a URL context factory.
     * This property may be specified in the environment,
     * an applet parameter, a system property, or one or more
     * resource files.
     * The prefix <tt>com.sun.jndi.url</tt> is always appended to
     * the possibly empty list of package prefixes.
     *
     * <p> The value of this constant is "java.naming.factory.url.pkgs".
     *
     * <p>
     *  常量,其中包含环境属性的名称,用于指定在URL上下文工厂中加载时要使用的程序包前缀列表。属性的值应该是将创建URL上下文工厂的工厂类的类名的包前缀的冒号分隔列表。
     * 可以在环境中指定此属性,小程序参数,系统属性或一个或多个资源文件。前缀<tt> com.sun.jndi.url </tt>始终附加到可能为空的包前缀列表。
     * 
     * <p>此常数的值为"java.naming.factory.url.pkgs"。
     * 
     * 
     * @see javax.naming.spi.NamingManager#getObjectInstance
     * @see javax.naming.spi.NamingManager#getURLContext
     * @see javax.naming.spi.ObjectFactory
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
      */
    String URL_PKG_PREFIXES = "java.naming.factory.url.pkgs";

    /**
     * Constant that holds the name of the environment property
     * for specifying configuration information for the service provider
     * to use. The value of the property should contain a URL string
     * (e.g. "ldap://somehost:389").
     * This property may be specified in the environment,
     * an applet parameter, a system property, or a resource file.
     * If it is not specified in any of these sources,
     * the default configuration is determined by the service provider.
     *
     * <p> The value of this constant is "java.naming.provider.url".
     *
     * <p>
     *  包含用于指定服务提供程序要使用的配置信息的environment属性的名称的常量。属性的值应包含网址字符串(例如"ldap：// somehost：389")。
     * 可以在环境中指定此属性,小程序参数,系统属性或资源文件。如果未在任何这些源中指定,则默认配置由服务提供商确定。
     * 
     *  <p>此常量的值为"java.naming.provider.url"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see #APPLET
     */
    String PROVIDER_URL = "java.naming.provider.url";

    /**
     * Constant that holds the name of the environment property
     * for specifying the DNS host and domain names to use for the
     * JNDI URL context (for example, "dns://somehost/wiz.com").
     * This property may be specified in the environment,
     * an applet parameter, a system property, or a resource file.
     * If it is not specified in any of these sources
     * and the program attempts to use a JNDI URL containing a DNS name,
     * a <tt>ConfigurationException</tt> will be thrown.
     *
     * <p> The value of this constant is "java.naming.dns.url".
     *
     * <p>
     *  包含用于指定用于JNDI URL上下文的DNS主机和域名(例如,"dns：//somehost/wiz.com")的environment属性的名称的常量。
     * 可以在环境中指定此属性,小程序参数,系统属性或资源文件。
     * 如果未在任何这些源中指定,并且程序尝试使用包含DNS名称的JNDI URL,则将抛出<tt> ConfigurationException </tt>。
     * 
     *  <p>此常量的值为"java.naming.dns.url"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String DNS_URL = "java.naming.dns.url";

    /**
     * Constant that holds the name of the environment property for
     * specifying the authoritativeness of the service requested.
     * If the value of the property is the string "true", it means
     * that the access is to the most authoritative source (i.e. bypass
     * any cache or replicas). If the value is anything else,
     * the source need not be (but may be) authoritative.
     * If unspecified, the value defaults to "false".
     *
     * <p> The value of this constant is "java.naming.authoritative".
     *
     * <p>
     *  包含用于指定所请求服务的权威性的环境属性的常量。如果属性的值是字符串"true",则意味着访问是最权威的源(即绕过任何高速缓存或副本)。如果值是其他值,源不需要(但可能)是权威的。
     * 如果未指定,该值默认为"false"。
     * 
     * <p>此常数的值为"java.naming.authoritative"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String AUTHORITATIVE = "java.naming.authoritative";

    /**
     * Constant that holds the name of the environment property for
     * specifying the batch size to use when returning data via the
     * service's protocol. This is a hint to the provider to return
     * the results of operations in batches of the specified size, so
     * the provider can optimize its performance and usage of resources.
     * The value of the property is the string representation of an
     * integer.
     * If unspecified, the batch size is determined by the service
     * provider.
     *
     * <p> The value of this constant is "java.naming.batchsize".
     *
     * <p>
     *  用于指定通过服务协议返回数据时要使用的批处理大小的环境属性的名称的常量。这是提示程序返回指定大小的批处理操作结果的提示,因此提供程序可以优化其性能和资源使用。属性的值是整数的字符串表示形式。
     * 如果未指定,批量大小由服务提供商确定。
     * 
     *  <p>此常数的值为"java.naming.batchsize"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String BATCHSIZE = "java.naming.batchsize";

    /**
     * Constant that holds the name of the environment property for
     * specifying how referrals encountered by the service provider
     * are to be processed. The value of the property is one of the
     * following strings:
     * <dl>
     * <dt>"follow"
     * <dd>follow referrals automatically
     * <dt>"ignore"
     * <dd>ignore referrals
     * <dt>"throw"
     * <dd>throw <tt>ReferralException</tt> when a referral is encountered.
     * </dl>
     * If this property is not specified, the default is
     * determined by the provider.
     *
     * <p> The value of this constant is "java.naming.referral".
     *
     * <p>
     *  包含用于指定如何处理服务提供者遇到的引荐的环境属性的名称的常量。属性的值是以下字符串之一：
     * <dl>
     *  <dt>"遇到引荐时,"跟随"<dd>自动跟随引荐<dt>"忽略"<dd>忽略引荐<dt>"throw"<dd>抛出<tt> ReferralException </tt>
     * </dl>
     *  如果未指定此属性,那么缺省值由提供程序确定。
     * 
     *  <p>此常数的值为"java.naming.referral"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String REFERRAL = "java.naming.referral";

    /**
     * Constant that holds the name of the environment property for
     * specifying the security protocol to use.
     * Its value is a string determined by the service provider
     * (e.g. "ssl").
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * <p> The value of this constant is "java.naming.security.protocol".
     *
     * <p>
     *  包含用于指定要使用的安全协议的environment属性的名称的常量。其值是由服务提供商确定的字符串(例如"ssl")。如果此属性未指定,则行为由服务提供程序确定。
     * 
     *  <p>此常量的值为"java.naming.security.protocol"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String SECURITY_PROTOCOL = "java.naming.security.protocol";

    /**
     * Constant that holds the name of the environment property for
     * specifying the security level to use.
     * Its value is one of the following strings:
     * "none", "simple", "strong".
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * <p> The value of this constant is "java.naming.security.authentication".
     *
     * <p>
     * 包含用于指定要使用的安全级别的environment属性的名称的常量。它的值是以下字符串之一："none","simple","strong"。如果此属性未指定,则行为由服务提供程序确定。
     * 
     *  <p>此常量的值为"java.naming.security.authentication"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String SECURITY_AUTHENTICATION = "java.naming.security.authentication";

    /**
     * Constant that holds the name of the environment property for
     * specifying the identity of the principal for authenticating
     * the caller to the service. The format of the principal
     * depends on the authentication scheme.
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * <p> The value of this constant is "java.naming.security.principal".
     *
     * <p>
     *  保存环境属性的常量,用于指定用于验证服务调用者的主体的身份。主体的格式取决于认证方案。如果此属性未指定,则行为由服务提供程序确定。
     * 
     *  <p>此常数的值为"java.naming.security.principal"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String SECURITY_PRINCIPAL = "java.naming.security.principal";

    /**
     * Constant that holds the name of the environment property for
     * specifying the credentials of the principal for authenticating
     * the caller to the service. The value of the property depends
     * on the authentication scheme. For example, it could be a hashed
     * password, clear-text password, key, certificate, and so on.
     * If this property is unspecified,
     * the behaviour is determined by the service provider.
     *
     * <p> The value of this constant is "java.naming.security.credentials".
     *
     * <p>
     *  用于指定用于验证服务调用者的主体凭据的环境属性的名称的常量。属性的值取决于认证方案。例如,它可以是散列密码,明文密码,密钥,证书等。如果此属性未指定,则行为由服务提供程序确定。
     * 
     *  <p>此常量的值为"java.naming.security.credentials"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */

    String SECURITY_CREDENTIALS = "java.naming.security.credentials";
    /**
     * Constant that holds the name of the environment property for
     * specifying the preferred language to use with the service.
     * The value of the property is a colon-separated list of language
     * tags as defined in RFC 1766.
     * If this property is unspecified,
     * the language preference is determined by the service provider.
     *
     * <p> The value of this constant is "java.naming.language".
     *
     * <p>
     *  保存环境属性的名称的常量,用于指定与服务一起使用的首选语言。属性的值是以冒号分隔的语言标记列表,如RFC 1766中定义的。如果此属性未指定,则语言首选项由服务提供商确定。
     * 
     * <p>此常数的值为"java.naming.language"。
     * 
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     */
    String LANGUAGE = "java.naming.language";

    /**
     * Constant that holds the name of the environment property for
     * specifying an applet for the initial context constructor to use
     * when searching for other properties.
     * The value of this property is the
     * <tt>java.applet.Applet</tt> instance that is being executed.
     * This property may be specified in the environment parameter
     * passed to the initial context constructor.
     * When this property is set, each property that the initial context
     * constructor looks for in the system properties is first looked for
     * in the applet's parameter list.
     * If this property is unspecified, the initial context constructor
     * will search for properties only in the environment parameter
     * passed to it, the system properties, and application resource files.
     *
     * <p> The value of this constant is "java.naming.applet".
     *
     * <p>
     *  保存环境属性的名称的常量,用于指定初始上下文构造函数在搜索其他属性时使用的小程序。此属性的值是正在执行的<tt> java.applet.Applet </tt>实例。
     * 此属性可以在传递给初始上下文构造函数的environment参数中指定。设置此属性时,首先在applet的参数列表中查找初始上下文构造函数在系统属性中查找的每个属性。
     * 如果此属性未指定,则初始上下文构造函数将仅在传递给它的环境参数,系统属性和应用程序资源文件中搜索属性。
     * 
     * @see #addToEnvironment(String, Object)
     * @see #removeFromEnvironment(String)
     * @see InitialContext
     *
     * @since 1.3
     */
    String APPLET = "java.naming.applet";
};
