/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package javax.annotation.processing;

import javax.tools.JavaFileManager;
import javax.tools.*;
import javax.lang.model.element.Element;
import java.io.IOException;

/**
 * This interface supports the creation of new files by an annotation
 * processor.  Files created in this way will be known to the
 * annotation processing tool implementing this interface, better
 * enabling the tool to manage them.  Source and class files so
 * created will be {@linkplain RoundEnvironment#getRootElements
 * considered for processing} by the tool in a subsequent {@linkplain
 * RoundEnvironment round of processing} after the {@code close}
 * method has been called on the {@code Writer} or {@code
 * OutputStream} used to write the contents of the file.
 *
 * Three kinds of files are distinguished: source files, class files,
 * and auxiliary resource files.
 *
 * <p> There are two distinguished supported locations (subtrees
 * within the logical file system) where newly created files are
 * placed: one for {@linkplain
 * javax.tools.StandardLocation#SOURCE_OUTPUT new source files}, and
 * one for {@linkplain javax.tools.StandardLocation#CLASS_OUTPUT new
 * class files}.  (These might be specified on a tool's command line,
 * for example, using flags such as {@code -s} and {@code -d}.)  The
 * actual locations for new source files and new class files may or
 * may not be distinct on a particular run of the tool.  Resource
 * files may be created in either location.  The methods for reading
 * and writing resources take a relative name argument.  A relative
 * name is a non-null, non-empty sequence of path segments separated
 * by {@code '/'}; {@code '.'} and {@code '..'} are invalid path
 * segments.  A valid relative name must match the
 * &quot;path-rootless&quot; rule of <a
 * href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>, section
 * 3.3.
 *
 * <p>The file creation methods take a variable number of arguments to
 * allow the <em>originating elements</em> to be provided as hints to
 * the tool infrastructure to better manage dependencies.  The
 * originating elements are the types or packages (representing {@code
 * package-info} files) which caused an annotation processor to
 * attempt to create a new file.  For example, if an annotation
 * processor tries to create a source file, {@code
 * GeneratedFromUserSource}, in response to processing
 *
 * <blockquote><pre>
 *  &#64;Generate
 *  public class UserSource {}
 * </pre></blockquote>
 *
 * the type element for {@code UserSource} should be passed as part of
 * the creation method call as in:
 *
 * <blockquote><pre>
 *      filer.createSourceFile("GeneratedFromUserSource",
 *                             eltUtils.getTypeElement("UserSource"));
 * </pre></blockquote>
 *
 * If there are no originating elements, none need to be passed.  This
 * information may be used in an incremental environment to determine
 * the need to rerun processors or remove generated files.
 * Non-incremental environments may ignore the originating element
 * information.
 *
 * <p> During each run of an annotation processing tool, a file with a
 * given pathname may be created only once.  If that file already
 * exists before the first attempt to create it, the old contents will
 * be deleted.  Any subsequent attempt to create the same file during
 * a run will throw a {@link FilerException}, as will attempting to
 * create both a class file and source file for the same type name or
 * same package name.  The {@linkplain Processor initial inputs} to
 * the tool are considered to be created by the zeroth round;
 * therefore, attempting to create a source or class file
 * corresponding to one of those inputs will result in a {@link
 * FilerException}.
 *
 * <p> In general, processors must not knowingly attempt to overwrite
 * existing files that were not generated by some processor.  A {@code
 * Filer} may reject attempts to open a file corresponding to an
 * existing type, like {@code java.lang.Object}.  Likewise, the
 * invoker of the annotation processing tool must not knowingly
 * configure the tool such that the discovered processors will attempt
 * to overwrite existing files that were not generated.
 *
 * <p> Processors can indicate a source or class file is generated by
 * including an {@link javax.annotation.Generated @Generated}
 * annotation.
 *
 * <p> Note that some of the effect of overwriting a file can be
 * achieved by using a <i>decorator</i>-style pattern.  Instead of
 * modifying a class directly, the class is designed so that either
 * its superclass is generated by annotation processing or subclasses
 * of the class are generated by annotation processing.  If the
 * subclasses are generated, the parent class may be designed to use
 * factories instead of public constructors so that only subclass
 * instances would be presented to clients of the parent class.
 *
 * <p>
 *  此接口支持注释处理器创建新文件。以这种方式创建的文件将为实现此接口的注释处理工具所知,更好地使工具能够管理它们。
 * 在{@code Writer}调用{@code close}方法之后,这样创建的源文件和类文件将被后面的{@linkplain RoundEnvironment round of processing}
 * 中的工具{@ linkplain RoundEnvironment#getRootElements考虑处理}或{@code OutputStream}用于写入文件的内容。
 *  此接口支持注释处理器创建新文件。以这种方式创建的文件将为实现此接口的注释处理工具所知,更好地使工具能够管理它们。
 * 
 *  区分三种文件：源文件,类文件和辅助资源文件。
 * 
 * <p>有两个支持的位置(逻辑文件系统中的子树),其中放置了新创建的文件：{@linkplain javax.tools.StandardLocation#SOURCE_OUTPUT新源文件},一个用于{@linkplain javax.tools .StandardLocation#CLASS_OUTPUT新类文件}
 * 。
 *  (这些可能在工具的命令行中指定,例如使用诸如{@code -s}和{@code -d}之类的标志。)新源文件和新类文件的实际位置可能不同或不同对工具的特定运行。可以在任一位置创建资源文件。
 * 用于读取和写入资源的方法使用相对名称参数。相对名称是由{@code'/'}分隔的路径段的非空,非空序列; {@code'。'}和{@code'..'}是无效的路径段。
 * 有效的相对名称必须匹配"无路径的" <a href="http://www.ietf.org/rfc/rfc3986.txt"> RFC 3986 </a>规则,第3.3节。
 * 
 *  <p>文件创建方法采用可变数量的参数,以允许将<em>始发元素</em>作为提示提供给工具基础结构,以更好地管理依赖关系。
 * 原始元素是导致注解处理器尝试创建新文件的类型或包(表示{@code package-info}文件)。
 * 例如,如果注释处理器尝试创建源文件{@code GeneratedFromUserSource},响应于处理。
 * 
 * <blockquote> <pre> @Generate public class UserSource {} </pre> </blockquote>
 * 
 *  {@code UserSource}的类型元素应该作为创建方法调用的一部分传递,如下所示：
 * 
 *  <blockquote> <pre> filer.createSourceFile("GeneratedFromUserSource",eltUtils.getTypeElement("UserSou
 * rce")); </pre> </blockquote>。
 * 
 *  如果没有始发元素,则不需要传递。此信息可用于增量环境中,以确定是否需要重新运行处理器或删除生成的文件。非增量环境可以忽略始发元素信息。
 * 
 *  <p>在每次运行注释处理工具期间,只能创建具有给定路径名的文件一次。如果该文件在首次尝试创建它之前已存在,则旧内容将被删除。
 * 任何后续在运行期间尝试创建同一文件的尝试将抛出一个{@link FilerException},将尝试为同一类型名称或相同包名称创建类文件和源文件。
 * 工具的{@linkplain处理器初始输入}被认为是由第零轮创建的;因此,尝试创建与这些输入之一对应的源或类文件将导致{@link FilerException}。
 * 
 * <p>通常,处理器不得故意试图覆盖某些处理器不生成的现有文件。 {@code Filer}可能会拒绝尝试打开与现有类型对应的文件,例如{@code java.lang.Object}。
 * 同样,注释处理工具的调用者不必故意地配置工具,使得发现的处理器将尝试覆盖未生成的现有文件。
 * 
 *  <p>处理程序可以指示通过包含{@link javax.annotation.Generated @Generated}注释生成的源文件或类文件。
 * 
 *  <p>请注意,覆盖文件的一些效果可以通过使用<i>装饰器</i>样式模式来实现。不是直接修改类,而是将类设计为使其超类通过注释处理生成,或者类的子类通过注释处理生成。
 * 
 * @author Joseph D. Darcy
 * @author Scott Seligman
 * @author Peter von der Ah&eacute;
 * @since 1.6
 */
public interface Filer {
    /**
     * Creates a new source file and returns an object to allow
     * writing to it.  The file's name and path (relative to the
     * {@linkplain StandardLocation#SOURCE_OUTPUT root output location
     * for source files}) are based on the type to be declared in that
     * file.  If more than one type is being declared, the name of the
     * principal top-level type (the public one, for example) should
     * be used.  A source file can also be created to hold information
     * about a package, including package annotations.  To create a
     * source file for a named package, have {@code name} be the
     * package's name followed by {@code ".package-info"}; to create a
     * source file for an unnamed package, use {@code "package-info"}.
     *
     * <p> Note that to use a particular {@linkplain
     * java.nio.charset.Charset charset} to encode the contents of the
     * file, an {@code OutputStreamWriter} with the chosen charset can
     * be created from the {@code OutputStream} from the returned
     * object. If the {@code Writer} from the returned object is
     * directly used for writing, its charset is determined by the
     * implementation.  An annotation processing tool may have an
     * {@code -encoding} flag or analogous option for specifying this;
     * otherwise, it will typically be the platform's default
     * encoding.
     *
     * <p>To avoid subsequent errors, the contents of the source file
     * should be compatible with the {@linkplain
     * ProcessingEnvironment#getSourceVersion source version} being used
     * for this run.
     *
     * <p>
     * 如果生成子类,则父类可以被设计为使用工厂而不是公共构造函数,使得只有子类实例将被呈现给父类的客户端。
     * 
     * 
     * @param name  canonical (fully qualified) name of the principal type
     *          being declared in this file or a package name followed by
     *          {@code ".package-info"} for a package information file
     * @param originatingElements type or package elements causally
     * associated with the creation of this file, may be elided or
     * {@code null}
     * @return a {@code JavaFileObject} to write the new source file
     * @throws FilerException if the same pathname has already been
     * created, the same type has already been created, or the name is
     * not valid for a type
     * @throws IOException if the file cannot be created
     */
    JavaFileObject createSourceFile(CharSequence name,
                                    Element... originatingElements) throws IOException;

    /**
     * Creates a new class file, and returns an object to allow
     * writing to it.  The file's name and path (relative to the
     * {@linkplain StandardLocation#CLASS_OUTPUT root output location
     * for class files}) are based on the name of the type being
     * written.  A class file can also be created to hold information
     * about a package, including package annotations.  To create a
     * class file for a named package, have {@code name} be the
     * package's name followed by {@code ".package-info"}; creating a
     * class file for an unnamed package is not supported.
     *
     * <p>To avoid subsequent errors, the contents of the class file
     * should be compatible with the {@linkplain
     * ProcessingEnvironment#getSourceVersion source version} being used
     * for this run.
     *
     * <p>
     * 创建一个新的源文件并返回一个对象允许写入它。文件的名称和路径(相对于{@linkplain StandardLocation#SOURCE_OUTPUT源文件的根输出位置))基于在该文件中声明的类型。
     * 如果正在声明多个类型,则应使用主要顶级类型的名称(例如,public类型)。还可以创建源文件以保存有关包的信息,包括包注释。
     * 要为命名包创建源文件,请使用{@code name}作为程序包名称,后跟{@code".package-info"};要为未命名的包创建源文件,请使用{@code"package-info"}。
     * 
     *  <p>请注意,要使用特定的{@linkplain java.nio.charset.Charset charset}来对文件内容进行编码,可以从{@code OutputStream}中创建一个带有所
     * 选字符集的{@code OutputStreamWriter}返回的对象。
     * 如果来自返回对象的{@code Writer}直接用于写入,则其字符集由实现决定。注释处理工具可以具有{@code -encoding}标志或用于指定该标志的类似选项;否则,它通常是平台的默认编码。
     * 
     *  <p>为避免后续错误,源文件的内容应与用于此运行的{@linkplain ProcessingEnvironment#getSourceVersion源版本}兼容。
     * 
     * 
     * @param name binary name of the type being written or a package name followed by
     *          {@code ".package-info"} for a package information file
     * @param originatingElements type or package elements causally
     * associated with the creation of this file, may be elided or
     * {@code null}
     * @return a {@code JavaFileObject} to write the new class file
     * @throws FilerException if the same pathname has already been
     * created, the same type has already been created, or the name is
     * not valid for a type
     * @throws IOException if the file cannot be created
     */
    JavaFileObject createClassFile(CharSequence name,
                                   Element... originatingElements) throws IOException;

    /**
     * Creates a new auxiliary resource file for writing and returns a
     * file object for it.  The file may be located along with the
     * newly created source files, newly created binary files, or
     * other supported location.  The locations {@link
     * StandardLocation#CLASS_OUTPUT CLASS_OUTPUT} and {@link
     * StandardLocation#SOURCE_OUTPUT SOURCE_OUTPUT} must be
     * supported.  The resource may be named relative to some package
     * (as are source and class files), and from there by a relative
     * pathname.  In a loose sense, the full pathname of the new file
     * will be the concatenation of {@code location}, {@code pkg}, and
     * {@code relativeName}.
     *
     * <p>Files created via this method are not registered for
     * annotation processing, even if the full pathname of the file
     * would correspond to the full pathname of a new source file
     * or new class file.
     *
     * <p>
     * 创建一个新的类文件,并返回一个对象允许写入它。文件的名称和路径(相对于{@linkplain StandardLocation#CLASS_OUTPUT类文件的根输出位置})基于正在写入的类型的名称。
     * 还可以创建类文件以保存有关包的信息,包括包注释。要为命名包创建类文件,请使用{@code name}作为程序包名称,后跟{@code".package-info"};不支持为未命名的包创建类文件。
     * 
     *  <p>为避免后续错误,类文件的内容应与用于此运行的{@linkplain ProcessingEnvironment#getSourceVersion源版本}兼容。
     * 
     * 
     * @param location location of the new file
     * @param pkg package relative to which the file should be named,
     *          or the empty string if none
     * @param relativeName final pathname components of the file
     * @param originatingElements type or package elements causally
     * associated with the creation of this file, may be elided or
     * {@code null}
     * @return a {@code FileObject} to write the new resource
     * @throws IOException if the file cannot be created
     * @throws FilerException if the same pathname has already been
     * created
     * @throws IllegalArgumentException for an unsupported location
     * @throws IllegalArgumentException if {@code relativeName} is not relative
     */
   FileObject createResource(JavaFileManager.Location location,
                             CharSequence pkg,
                             CharSequence relativeName,
                             Element... originatingElements) throws IOException;

    /**
     * Returns an object for reading an existing resource.  The
     * locations {@link StandardLocation#CLASS_OUTPUT CLASS_OUTPUT}
     * and {@link StandardLocation#SOURCE_OUTPUT SOURCE_OUTPUT} must
     * be supported.
     *
     * <p>
     *  创建用于写入的新辅助资源文件,并为其返回文件对象。该文件可以与新创建的源文件,新创建的二进制文件或其他支持的位置一起被定位。
     * 必须支持位置{@link StandardLocation#CLASS_OUTPUT CLASS_OUTPUT}和{@link StandardLocation#SOURCE_OUTPUT SOURCE_OUTPUT}
     * 。
     *  创建用于写入的新辅助资源文件,并为其返回文件对象。该文件可以与新创建的源文件,新创建的二进制文件或其他支持的位置一起被定位。
     * 资源可以相对于一些包命名(如同源文件和类文件一样),并且可以通过相对路径名来命名。
     * 在松散的意义上,新文件的完整路径名将是{@code location},{@code pkg}和{@code relativeName}的连接。
     * 
     * <p>通过此方法创建的文件不会注册为注释处理,即使文件的完整路径名对应于新源文件或新类文件的完整路径名。
     * 
     * @param location location of the file
     * @param pkg package relative to which the file should be searched,
     *          or the empty string if none
     * @param relativeName final pathname components of the file
     * @return an object to read the file
     * @throws FilerException if the same pathname has already been
     * opened for writing
     * @throws IOException if the file cannot be opened
     * @throws IllegalArgumentException for an unsupported location
     * @throws IllegalArgumentException if {@code relativeName} is not relative
     */
    FileObject getResource(JavaFileManager.Location location,
                           CharSequence pkg,
                           CharSequence relativeName) throws IOException;
}
