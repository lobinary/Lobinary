/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.awt.event;

import java.awt.Component;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.io.IOException;
import java.io.ObjectInputStream;
import sun.awt.AWTAccessor;

/**
 * An event which indicates that a keystroke occurred in a component.
 * <p>
 * This low-level event is generated by a component object (such as a text
 * field) when a key is pressed, released, or typed.
 * The event is passed to every <code>KeyListener</code>
 * or <code>KeyAdapter</code> object which registered to receive such
 * events using the component's <code>addKeyListener</code> method.
 * (<code>KeyAdapter</code> objects implement the
 * <code>KeyListener</code> interface.)  Each such listener object
 * gets this <code>KeyEvent</code> when the event occurs.
 * <p>
 * <em>"Key typed" events</em> are higher-level and generally do not depend on
 * the platform or keyboard layout.  They are generated when a Unicode character
 * is entered, and are the preferred way to find out about character input.
 * In the simplest case, a key typed event is produced by a single key press
 * (e.g., 'a').  Often, however, characters are produced by series of key
 * presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to
 * key typed events may be many-to-one or many-to-many.  Key releases are not
 * usually necessary to generate a key typed event, but there are some cases
 * where the key typed event is not generated until a key is released (e.g.,
 * entering ASCII sequences via the Alt-Numpad method in Windows).
 * No key typed events are generated for keys that don't generate Unicode
 * characters (e.g., action keys, modifier keys, etc.).
 * <p>
 * The getKeyChar method always returns a valid Unicode character or
 * CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:
 * KEY_PRESSED and KEY_RELEASED events are not necessarily associated
 * with character input.  Therefore, the result of the getKeyChar method
 * is guaranteed to be meaningful only for KEY_TYPED events.
 * <p>
 * For key pressed and key released events, the getKeyCode method returns
 * the event's keyCode.  For key typed events, the getKeyCode method
 * always returns {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method
 * may also be used with many international keyboard layouts.
 *
 * <p>
 * <em>"Key pressed" and "key released" events</em> are lower-level and depend
 * on the platform and keyboard layout. They are generated whenever a key is
 * pressed or released, and are the only way to find out about keys that don't
 * generate character input (e.g., action keys, modifier keys, etc.). The key
 * being pressed or released is indicated by the {@code getKeyCode} and {@code getExtendedKeyCode}
 * methods, which return a virtual key code.
 *
 * <p>
 * <em>Virtual key codes</em> are used to report which keyboard key has
 * been pressed, rather than a character generated by the combination
 * of one or more keystrokes (such as "A", which comes from shift and "a").
 *
 * <p>
 * For example, pressing the Shift key will cause a KEY_PRESSED event
 * with a VK_SHIFT keyCode, while pressing the 'a' key will result in
 * a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event
 * will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar
 * value of 'A' is generated.
 *
 * <p>
 * Pressing and releasing a key on the keyboard results in the generating
 * the following key events (in order):
 * <PRE>
 *    {@code KEY_PRESSED}
 *    {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
 *    {@code KEY_RELEASED}
 * </PRE>
 *
 * But in some cases (e.g. auto-repeat or input method is activated) the order
 * could be different (and platform dependent).
 *
 * <p>
 * Notes:
 * <ul>
 * <li>Key combinations which do not result in Unicode characters, such as action
 * keys like F1 and the HELP key, do not generate KEY_TYPED events.
 * <li>Not all keyboards or systems are capable of generating all
 * virtual key codes.  No attempt is made in Java to generate these keys
 * artificially.
 * <li>Virtual key codes do not identify a physical key: they depend on the
 * platform and keyboard layout. For example, the key that generates VK_Q
 * when using a U.S. keyboard layout will generate VK_A when using a French
 * keyboard layout.
 * <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout also
 * generates a unique code for Russian or Hebrew layout. There is no a
 * {@code VK_} constant for these and many other codes in various layouts. These codes
 * may be obtained by using {@code getExtendedKeyCode} and are used whenever
 * a {@code VK_} constant is used.
 * <li>Not all characters have a keycode associated with them.  For example,
 * there is no keycode for the question mark because there is no keyboard
 * for which it appears on the primary layer.
 * <li>In order to support the platform-independent handling of action keys,
 * the Java platform uses a few additional virtual key constants for functions
 * that would otherwise have to be recognized by interpreting virtual key codes
 * and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
 * is returned instead of VK_CONVERT with the ALT modifier.
 * <li>As specified in <a href="../doc-files/FocusSpec.html">Focus Specification</a>
 * key events are dispatched to the focus owner by default.
 * </ul>
 *
 * <p>
 * WARNING: Aside from those keys that are defined by the Java language
 * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
 * constants.  Sun reserves the right to change these values as needed
 * to accommodate a wider range of keyboards in the future.
 * <p>
 * An unspecified behavior will be caused if the {@code id} parameter
 * of any particular {@code KeyEvent} instance is not
 * in the range from {@code KEY_FIRST} to {@code KEY_LAST}.
 *
 * <p>
 *  指示组件中发生击键的事件
 * <p>
 *  当按下,释放或键入一个键时,该低级事件由组件对象(例如文本字段)生成。
 * 事件被传递到每个<code> KeyListener </code>或<code> KeyAdapter </code >对象使用组件的<code> addKeyListener </code>方法(<code>
 *  KeyAdapter </code>对象实现<code> KeyListener </code>接口)注册接收这样的事件每个这样的监听器对象获得这< > KeyEvent </code>。
 *  当按下,释放或键入一个键时,该低级事件由组件对象(例如文本字段)生成。
 * <p>
 * <em>"键入的"事件</em>是更高级别的,通常不依赖于平台或键盘布局它们是在输入Unicode字符时生成的,并且是查找字符输入的首选方式。
 * 最简单的情况是,通过单个按键(例如,"a")产生键类型事件。
 * 然而,通常,通过一系列键按压(例如,'shift'+'a')产生字符,按键事件到键类型事件可以是多对一或多对多键发布通常不是生成键类型事件所必需的,但是在某些情况下,键类型事件直到键释放才会生成(例如,
 * 在Windows中通过Alt-Numpad方法输入ASCII序列)对于不生成Unicode字符的键,不生成键类型事件(例如,动作键,修饰键等)。
 * 最简单的情况是,通过单个按键(例如,"a")产生键类型事件。
 * <p>
 * getKeyChar方法总是返回一个有效的Unicode字符或CHAR_UNDEFINED KEY_TYPED事件报告的字符输入：KEY_PRESSED和KEY_RELEASED事件不一定与字符输入相关
 * 联因此,getKeyChar方法的结果保证仅对KEY_TYPED事件有意义。
 * <p>
 *  对于按键和键释放的事件,getKeyCode方法返回事件的keyCode对于键入类型的事件,getKeyCode方法总是返回{@code VK_UNDEFINED} {@code getExtendedKeyCode}
 * 方法也可用于许多国际键盘布局。
 * 
 * <p>
 * <em>"按键按下"和"按键释放"事件是较低级别的,取决于平台和键盘布局它们是在按下或释放按键时生成的,并且是查找按键的唯一方法不会生成字符输入(例如,动作键,修饰键等)被按下或释放的键由{@code getKeyCode}
 * 和{@code getExtendedKeyCode}方法指示,它们返回虚拟键代码。
 * 
 * <p>
 *  <em>虚拟键代码</em>用于报告已按下的键盘琴键,而不是由一个或多个击键(例如"A",来自shift和"a")的组合生成的字符
 * 
 * <p>
 * 例如,按Shift键将导致带有VK_SHIFT keyCode的KEY_PRESSED事件,而按'a'键将导致VK_A keyCode在释放"a"键后,将使用VK_A单独触发KEY_RELEASED事件
 * 生成keyChar值为'A'的KEY_TYPED事件。
 * 
 * <p>
 *  按下和释放键盘上的键将导致生成以下键事件(按顺序)：
 * <PRE>
 *  {@code KEY_PRESSED} {@code KEY_TYPED}(仅在生成有效的Unicode字符时生成){@code KEY_RELEASED}
 * </PRE>
 * 
 *  但在某些情况下(例如自动重复或输入法被激活),顺序可以是不同的(并且取决于平台)
 * 
 * <p>
 *  笔记：
 * <ul>
 * <li>不会导致Unicode字符的组合键(例如F1和帮助键等操作键)不会生成KEY_TYPED事件<li>并非所有键盘或系统都能生成所有虚拟键代码。
 *  Java人工生成这些键<li>虚拟键代码不识别物理键：它们取决于平台和键盘布局例如,使用美式键盘布局时生成VK_Q的键将在使用法语键盘布局时生成VK_A <li>使用美式键盘布局时生成{@code VK_Q}
 * 的键还会为俄语或希伯来语布局生成唯一代码对于这些和许多其他代码,在各种布局中没有{@code VK_}常量这些代码可以通过使用{@code getExtendedKeyCode}获得,并且在使用{@code VK_}
 * 常数时被使用<li>并非所有字符都具有与其相关联的键码。
 * <li>不会导致Unicode字符的组合键(例如F1和帮助键等操作键)不会生成KEY_TYPED事件<li>并非所有键盘或系统都能生成所有虚拟键代码。
 * 例如,没有用于问号的键码,因为是不出现在主层上的键盘<li>为了支持与操作键的平台无关的处理,Java平台为函数使用一些额外的虚拟键常量,否则必须通过解释虚拟键来识别代码和修饰符例如,对于日语Windo
 * ws键盘,返回VK_ALL_CANDIDATES,而不是带有ALT修饰符的VK_CONVERT <li>如<a href=\"/doc-files/FocusSpechtml\">焦点规范</a>中所指
 * 定的,到焦点所有者。
 * <li>不会导致Unicode字符的组合键(例如F1和帮助键等操作键)不会生成KEY_TYPED事件<li>并非所有键盘或系统都能生成所有虚拟键代码。
 * </ul>
 * 
 * <p>
 * 警告：除了由Java语言(VK_ENTER,VK_BACK_SPACE和VK_TAB)定义的那些键之外,不要依赖于VK_常量的值。Sun保留根据需要更改这些值的权利,以适应更宽范围的键盘未来
 * <p>
 *  如果任何特定{@code KeyEvent}实例的{@code id}参数不在{@code KEY_FIRST}到{@code KEY_LAST}的范围内,则会导致未指定的行为。
 * 
 * 
 * @author Carl Quinn
 * @author Amy Fowler
 * @author Norbert Lindenberg
 *
 * @see KeyAdapter
 * @see KeyListener
 * @see <a href="https://docs.oracle.com/javase/tutorial/uiswing/events/keylistener.html">Tutorial: Writing a Key Listener</a>
 *
 * @since 1.1
 */
public class KeyEvent extends InputEvent {

    /**
     * Stores the state of native event dispatching system
     * - true, if when the event was created event proxying
     *         mechanism was active
     * - false, if it was inactive
     * Used in Component.dispatchEventImpl to correctly dispatch
     * events when proxy is active
     * <p>
     *  存储本机事件分派系统的状态 - 如果事件已创建事件代理机制处于活动状态,则为true  - 如果处于非活动状态,则为false  - 在ComponentdispatchEventImpl中用于在代理
     * 处于活动状态时正确分派事件。
     * 
     */
    private boolean isProxyActive = false;

    /**
     * The first number in the range of ids used for key events.
     * <p>
     *  用于键事件的ids范围中的第一个数字
     * 
     */
    public static final int KEY_FIRST = 400;

    /**
     * The last number in the range of ids used for key events.
     * <p>
     * 用于键事件的ids范围中的最后一个数字
     * 
     */
    public static final int KEY_LAST  = 402;

    /**
     * The "key typed" event.  This event is generated when a character is
     * entered.  In the simplest case, it is produced by a single key press.
     * Often, however, characters are produced by series of key presses, and
     * the mapping from key pressed events to key typed events may be
     * many-to-one or many-to-many.
     * <p>
     *  "键入类型"事件当输入字符时产生该事件在最简单的情况下,它是由单个键按压产生的。然而,通常,通过一系列按键产生字符,并且从按键事件到键的映射类型事件可以是多对一或多对多
     * 
     */
    public static final int KEY_TYPED = KEY_FIRST;

    /**
     * The "key pressed" event. This event is generated when a key
     * is pushed down.
     * <p>
     *  "按键"事件当按下键时产生此事件
     * 
     */
    public static final int KEY_PRESSED = 1 + KEY_FIRST; //Event.KEY_PRESS

    /**
     * The "key released" event. This event is generated when a key
     * is let up.
     * <p>
     *  "释放键"事件当一个键被释放时,产生此事件
     * 
     */
    public static final int KEY_RELEASED = 2 + KEY_FIRST; //Event.KEY_RELEASE

    /* Virtual key codes. */

    public static final int VK_ENTER          = '\n';
    public static final int VK_BACK_SPACE     = '\b';
    public static final int VK_TAB            = '\t';
    public static final int VK_CANCEL         = 0x03;
    public static final int VK_CLEAR          = 0x0C;
    public static final int VK_SHIFT          = 0x10;
    public static final int VK_CONTROL        = 0x11;
    public static final int VK_ALT            = 0x12;
    public static final int VK_PAUSE          = 0x13;
    public static final int VK_CAPS_LOCK      = 0x14;
    public static final int VK_ESCAPE         = 0x1B;
    public static final int VK_SPACE          = 0x20;
    public static final int VK_PAGE_UP        = 0x21;
    public static final int VK_PAGE_DOWN      = 0x22;
    public static final int VK_END            = 0x23;
    public static final int VK_HOME           = 0x24;

    /**
     * Constant for the non-numpad <b>left</b> arrow key.
     * <p>
     *  非数字键盘<b>左</b>箭头键的常数
     * 
     * 
     * @see #VK_KP_LEFT
     */
    public static final int VK_LEFT           = 0x25;

    /**
     * Constant for the non-numpad <b>up</b> arrow key.
     * <p>
     *  非数字键盘<b>向上</b>箭头键的常数
     * 
     * 
     * @see #VK_KP_UP
     */
    public static final int VK_UP             = 0x26;

    /**
     * Constant for the non-numpad <b>right</b> arrow key.
     * <p>
     *  非数字键盘<b>右</b>箭头键的常数
     * 
     * 
     * @see #VK_KP_RIGHT
     */
    public static final int VK_RIGHT          = 0x27;

    /**
     * Constant for the non-numpad <b>down</b> arrow key.
     * <p>
     *  非数字键<b>向下</b>箭头键的常数
     * 
     * 
     * @see #VK_KP_DOWN
     */
    public static final int VK_DOWN           = 0x28;

    /**
     * Constant for the comma key, ","
     * <p>
     *  逗号键的常量,","
     * 
     */
    public static final int VK_COMMA          = 0x2C;

    /**
     * Constant for the minus key, "-"
     * <p>
     *  减号键的常数," - "
     * 
     * 
     * @since 1.2
     */
    public static final int VK_MINUS          = 0x2D;

    /**
     * Constant for the period key, "."
     * <p>
     * 周期键的常数,""
     * 
     */
    public static final int VK_PERIOD         = 0x2E;

    /**
     * Constant for the forward slash key, "/"
     * <p>
     *  正斜杠键的常数,"/"
     * 
     */
    public static final int VK_SLASH          = 0x2F;

    /** VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
    public static final int VK_0              = 0x30;
    public static final int VK_1              = 0x31;
    public static final int VK_2              = 0x32;
    public static final int VK_3              = 0x33;
    public static final int VK_4              = 0x34;
    public static final int VK_5              = 0x35;
    public static final int VK_6              = 0x36;
    public static final int VK_7              = 0x37;
    public static final int VK_8              = 0x38;
    public static final int VK_9              = 0x39;

    /**
     * Constant for the semicolon key, ";"
     * <p>
     *  常量为分号键,";"
     * 
     */
    public static final int VK_SEMICOLON      = 0x3B;

    /**
     * Constant for the equals key, "="
     * <p>
     *  等于键的常量,"="
     * 
     */
    public static final int VK_EQUALS         = 0x3D;

    /** VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
    public static final int VK_A              = 0x41;
    public static final int VK_B              = 0x42;
    public static final int VK_C              = 0x43;
    public static final int VK_D              = 0x44;
    public static final int VK_E              = 0x45;
    public static final int VK_F              = 0x46;
    public static final int VK_G              = 0x47;
    public static final int VK_H              = 0x48;
    public static final int VK_I              = 0x49;
    public static final int VK_J              = 0x4A;
    public static final int VK_K              = 0x4B;
    public static final int VK_L              = 0x4C;
    public static final int VK_M              = 0x4D;
    public static final int VK_N              = 0x4E;
    public static final int VK_O              = 0x4F;
    public static final int VK_P              = 0x50;
    public static final int VK_Q              = 0x51;
    public static final int VK_R              = 0x52;
    public static final int VK_S              = 0x53;
    public static final int VK_T              = 0x54;
    public static final int VK_U              = 0x55;
    public static final int VK_V              = 0x56;
    public static final int VK_W              = 0x57;
    public static final int VK_X              = 0x58;
    public static final int VK_Y              = 0x59;
    public static final int VK_Z              = 0x5A;

    /**
     * Constant for the open bracket key, "["
     * <p>
     *  开括号键的常数,"["
     * 
     */
    public static final int VK_OPEN_BRACKET   = 0x5B;

    /**
     * Constant for the back slash key, "\"
     * <p>
     *  反斜杠键的常量,"\\"
     * 
     */
    public static final int VK_BACK_SLASH     = 0x5C;

    /**
     * Constant for the close bracket key, "]"
     * <p>
     *  右括号键的常数,"]"
     * 
     */
    public static final int VK_CLOSE_BRACKET  = 0x5D;

    public static final int VK_NUMPAD0        = 0x60;
    public static final int VK_NUMPAD1        = 0x61;
    public static final int VK_NUMPAD2        = 0x62;
    public static final int VK_NUMPAD3        = 0x63;
    public static final int VK_NUMPAD4        = 0x64;
    public static final int VK_NUMPAD5        = 0x65;
    public static final int VK_NUMPAD6        = 0x66;
    public static final int VK_NUMPAD7        = 0x67;
    public static final int VK_NUMPAD8        = 0x68;
    public static final int VK_NUMPAD9        = 0x69;
    public static final int VK_MULTIPLY       = 0x6A;
    public static final int VK_ADD            = 0x6B;

    /**
     * This constant is obsolete, and is included only for backwards
     * compatibility.
     * <p>
     *  此常量已过时,仅用于向后兼容性
     * 
     * 
     * @see #VK_SEPARATOR
     */
    public static final int VK_SEPARATER      = 0x6C;

    /**
     * Constant for the Numpad Separator key.
     * <p>
     *  Numpad分隔符键的常量
     * 
     * 
     * @since 1.4
     */
    public static final int VK_SEPARATOR      = VK_SEPARATER;

    public static final int VK_SUBTRACT       = 0x6D;
    public static final int VK_DECIMAL        = 0x6E;
    public static final int VK_DIVIDE         = 0x6F;
    public static final int VK_DELETE         = 0x7F; /* ASCII DEL */
    public static final int VK_NUM_LOCK       = 0x90;
    public static final int VK_SCROLL_LOCK    = 0x91;

    /** Constant for the F1 function key. */
    public static final int VK_F1             = 0x70;

    /** Constant for the F2 function key. */
    public static final int VK_F2             = 0x71;

    /** Constant for the F3 function key. */
    public static final int VK_F3             = 0x72;

    /** Constant for the F4 function key. */
    public static final int VK_F4             = 0x73;

    /** Constant for the F5 function key. */
    public static final int VK_F5             = 0x74;

    /** Constant for the F6 function key. */
    public static final int VK_F6             = 0x75;

    /** Constant for the F7 function key. */
    public static final int VK_F7             = 0x76;

    /** Constant for the F8 function key. */
    public static final int VK_F8             = 0x77;

    /** Constant for the F9 function key. */
    public static final int VK_F9             = 0x78;

    /** Constant for the F10 function key. */
    public static final int VK_F10            = 0x79;

    /** Constant for the F11 function key. */
    public static final int VK_F11            = 0x7A;

    /** Constant for the F12 function key. */
    public static final int VK_F12            = 0x7B;

    /**
     * Constant for the F13 function key.
     * <p>
     *  F13功能键的常数
     * 
     * 
     * @since 1.2
     */
    /* F13 - F24 are used on IBM 3270 keyboard; use random range for constants. */
    public static final int VK_F13            = 0xF000;

    /**
     * Constant for the F14 function key.
     * <p>
     *  F14功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F14            = 0xF001;

    /**
     * Constant for the F15 function key.
     * <p>
     *  F15功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F15            = 0xF002;

    /**
     * Constant for the F16 function key.
     * <p>
     *  F16功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F16            = 0xF003;

    /**
     * Constant for the F17 function key.
     * <p>
     *  F17功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F17            = 0xF004;

    /**
     * Constant for the F18 function key.
     * <p>
     *  F18功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F18            = 0xF005;

    /**
     * Constant for the F19 function key.
     * <p>
     *  F19功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F19            = 0xF006;

    /**
     * Constant for the F20 function key.
     * <p>
     *  F20功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F20            = 0xF007;

    /**
     * Constant for the F21 function key.
     * <p>
     *  F21功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F21            = 0xF008;

    /**
     * Constant for the F22 function key.
     * <p>
     *  F22功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F22            = 0xF009;

    /**
     * Constant for the F23 function key.
     * <p>
     *  F23功能键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F23            = 0xF00A;

    /**
     * Constant for the F24 function key.
     * <p>
     * F24功能键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_F24            = 0xF00B;

    public static final int VK_PRINTSCREEN    = 0x9A;
    public static final int VK_INSERT         = 0x9B;
    public static final int VK_HELP           = 0x9C;
    public static final int VK_META           = 0x9D;

    public static final int VK_BACK_QUOTE     = 0xC0;
    public static final int VK_QUOTE          = 0xDE;

    /**
     * Constant for the numeric keypad <b>up</b> arrow key.
     * <p>
     *  数字键盘的常数<b>向上</b>箭头键
     * 
     * 
     * @see #VK_UP
     * @since 1.2
     */
    public static final int VK_KP_UP          = 0xE0;

    /**
     * Constant for the numeric keypad <b>down</b> arrow key.
     * <p>
     *  数字键盘的常数<b>向下</b>箭头键
     * 
     * 
     * @see #VK_DOWN
     * @since 1.2
     */
    public static final int VK_KP_DOWN        = 0xE1;

    /**
     * Constant for the numeric keypad <b>left</b> arrow key.
     * <p>
     *  数字键盘的常数<b>左</b>箭头键
     * 
     * 
     * @see #VK_LEFT
     * @since 1.2
     */
    public static final int VK_KP_LEFT        = 0xE2;

    /**
     * Constant for the numeric keypad <b>right</b> arrow key.
     * <p>
     *  数字键盘的常数<b>向右</b>箭头键
     * 
     * 
     * @see #VK_RIGHT
     * @since 1.2
     */
    public static final int VK_KP_RIGHT       = 0xE3;

    /* For European keyboards */
    /** @since 1.2 */
    public static final int VK_DEAD_GRAVE               = 0x80;
    /** @since 1.2 */
    public static final int VK_DEAD_ACUTE               = 0x81;
    /** @since 1.2 */
    public static final int VK_DEAD_CIRCUMFLEX          = 0x82;
    /** @since 1.2 */
    public static final int VK_DEAD_TILDE               = 0x83;
    /** @since 1.2 */
    public static final int VK_DEAD_MACRON              = 0x84;
    /** @since 1.2 */
    public static final int VK_DEAD_BREVE               = 0x85;
    /** @since 1.2 */
    public static final int VK_DEAD_ABOVEDOT            = 0x86;
    /** @since 1.2 */
    public static final int VK_DEAD_DIAERESIS           = 0x87;
    /** @since 1.2 */
    public static final int VK_DEAD_ABOVERING           = 0x88;
    /** @since 1.2 */
    public static final int VK_DEAD_DOUBLEACUTE         = 0x89;
    /** @since 1.2 */
    public static final int VK_DEAD_CARON               = 0x8a;
    /** @since 1.2 */
    public static final int VK_DEAD_CEDILLA             = 0x8b;
    /** @since 1.2 */
    public static final int VK_DEAD_OGONEK              = 0x8c;
    /** @since 1.2 */
    public static final int VK_DEAD_IOTA                = 0x8d;
    /** @since 1.2 */
    public static final int VK_DEAD_VOICED_SOUND        = 0x8e;
    /** @since 1.2 */
    public static final int VK_DEAD_SEMIVOICED_SOUND    = 0x8f;

    /** @since 1.2 */
    public static final int VK_AMPERSAND                = 0x96;
    /** @since 1.2 */
    public static final int VK_ASTERISK                 = 0x97;
    /** @since 1.2 */
    public static final int VK_QUOTEDBL                 = 0x98;
    /** @since 1.2 */
    public static final int VK_LESS                     = 0x99;

    /** @since 1.2 */
    public static final int VK_GREATER                  = 0xa0;
    /** @since 1.2 */
    public static final int VK_BRACELEFT                = 0xa1;
    /** @since 1.2 */
    public static final int VK_BRACERIGHT               = 0xa2;

    /**
     * Constant for the "@" key.
     * <p>
     *  "@"键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_AT                       = 0x0200;

    /**
     * Constant for the ":" key.
     * <p>
     *  "："键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_COLON                    = 0x0201;

    /**
     * Constant for the "^" key.
     * <p>
     *  "^"键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_CIRCUMFLEX               = 0x0202;

    /**
     * Constant for the "$" key.
     * <p>
     *  "$"键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_DOLLAR                   = 0x0203;

    /**
     * Constant for the Euro currency sign key.
     * <p>
     *  欧元货币符号键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_EURO_SIGN                = 0x0204;

    /**
     * Constant for the "!" key.
     * <p>
     *  常数为"！"键
     * 
     * 
     * @since 1.2
     */
    public static final int VK_EXCLAMATION_MARK         = 0x0205;

    /**
     * Constant for the inverted exclamation mark key.
     * <p>
     *  反转感叹号键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;

    /**
     * Constant for the "(" key.
     * <p>
     *  常量为"("键
     * 
     * 
     * @since 1.2
     */
    public static final int VK_LEFT_PARENTHESIS         = 0x0207;

    /**
     * Constant for the "#" key.
     * <p>
     *  "#"键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_NUMBER_SIGN              = 0x0208;

    /**
     * Constant for the "+" key.
     * <p>
     *  "+"键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_PLUS                     = 0x0209;

    /**
     * Constant for the ")" key.
     * <p>
     *  ")"键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_RIGHT_PARENTHESIS        = 0x020A;

    /**
     * Constant for the "_" key.
     * <p>
     *  "_"键的常数
     * 
     * 
     * @since 1.2
     */
    public static final int VK_UNDERSCORE               = 0x020B;

    /**
     * Constant for the Microsoft Windows "Windows" key.
     * It is used for both the left and right version of the key.
     * <p>
     *  Microsoft Windows"Windows"键的常量它用于左和右版本的键
     * 
     * 
     * @see #getKeyLocation()
     * @since 1.5
     */
    public static final int VK_WINDOWS                  = 0x020C;

    /**
     * Constant for the Microsoft Windows Context Menu key.
     * <p>
     *  Microsoft Windows上下文菜单键的常量
     * 
     * 
     * @since 1.5
     */
    public static final int VK_CONTEXT_MENU             = 0x020D;

    /* for input method support on Asian Keyboards */

    /* not clear what this means - listed in Microsoft Windows API */
    public static final int VK_FINAL                    = 0x0018;

    /** Constant for the Convert function key. */
    /* Japanese PC 106 keyboard, Japanese Solaris keyboard: henkan */
    public static final int VK_CONVERT                  = 0x001C;

    /** Constant for the Don't Convert function key. */
    /* Japanese PC 106 keyboard: muhenkan */
    public static final int VK_NONCONVERT               = 0x001D;

    /** Constant for the Accept or Commit function key. */
    /* Japanese Solaris keyboard: kakutei */
    public static final int VK_ACCEPT                   = 0x001E;

    /* not clear what this means - listed in Microsoft Windows API */
    public static final int VK_MODECHANGE               = 0x001F;

    /* replaced by VK_KANA_LOCK for Microsoft Windows and Solaris;
    /* <p>
    /* 
       might still be used on other platforms */
    public static final int VK_KANA                     = 0x0015;

    /* replaced by VK_INPUT_METHOD_ON_OFF for Microsoft Windows and Solaris;
    /* <p>
    /* 
       might still be used for other platforms */
    public static final int VK_KANJI                    = 0x0019;

    /**
     * Constant for the Alphanumeric function key.
     * <p>
     * 字母数字功能键的常数
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: eisuu */
    public static final int VK_ALPHANUMERIC             = 0x00F0;

    /**
     * Constant for the Katakana function key.
     * <p>
     *  片假名功能键的常量
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: katakana */
    public static final int VK_KATAKANA                 = 0x00F1;

    /**
     * Constant for the Hiragana function key.
     * <p>
     *  平假名功能键的常量
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: hiragana */
    public static final int VK_HIRAGANA                 = 0x00F2;

    /**
     * Constant for the Full-Width Characters function key.
     * <p>
     *  全角字符功能键的常量
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: zenkaku */
    public static final int VK_FULL_WIDTH               = 0x00F3;

    /**
     * Constant for the Half-Width Characters function key.
     * <p>
     *  半角字符功能键的常量
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: hankaku */
    public static final int VK_HALF_WIDTH               = 0x00F4;

    /**
     * Constant for the Roman Characters function key.
     * <p>
     *  罗马字符功能键的常量
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: roumaji */
    public static final int VK_ROMAN_CHARACTERS         = 0x00F5;

    /**
     * Constant for the All Candidates function key.
     * <p>
     *  All Candidates功能键的常数
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard - VK_CONVERT + ALT: zenkouho */
    public static final int VK_ALL_CANDIDATES           = 0x0100;

    /**
     * Constant for the Previous Candidate function key.
     * <p>
     *  上一个候选功能键的常数
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard - VK_CONVERT + SHIFT: maekouho */
    public static final int VK_PREVIOUS_CANDIDATE       = 0x0101;

    /**
     * Constant for the Code Input function key.
     * <p>
     *  代码输入功能键的常数
     * 
     * 
     * @since 1.2
     */
    /* Japanese PC 106 keyboard - VK_ALPHANUMERIC + ALT: kanji bangou */
    public static final int VK_CODE_INPUT               = 0x0102;

    /**
     * Constant for the Japanese-Katakana function key.
     * This key switches to a Japanese input method and selects its Katakana input mode.
     * <p>
     *  日语片假名功能键的常数此键切换到日语输入法,并选择其片假名输入模式
     * 
     * 
     * @since 1.2
     */
    /* Japanese Macintosh keyboard - VK_JAPANESE_HIRAGANA + SHIFT */
    public static final int VK_JAPANESE_KATAKANA        = 0x0103;

    /**
     * Constant for the Japanese-Hiragana function key.
     * This key switches to a Japanese input method and selects its Hiragana input mode.
     * <p>
     *  日语 - 平假名功能键的常数此键切换到日语输入法,并选择其平假名输入模式
     * 
     * 
     * @since 1.2
     */
    /* Japanese Macintosh keyboard */
    public static final int VK_JAPANESE_HIRAGANA        = 0x0104;

    /**
     * Constant for the Japanese-Roman function key.
     * This key switches to a Japanese input method and selects its Roman-Direct input mode.
     * <p>
     * 日语 - 罗马功能键的常数此键切换到日语输入法,并选择其Roman-Direct输入模式
     * 
     * 
     * @since 1.2
     */
    /* Japanese Macintosh keyboard */
    public static final int VK_JAPANESE_ROMAN           = 0x0105;

    /**
     * Constant for the locking Kana function key.
     * This key locks the keyboard into a Kana layout.
     * <p>
     *  锁定Kana功能键的常数此键将键盘锁定为Kana布局
     * 
     * 
     * @since 1.3
     */
    /* Japanese PC 106 keyboard with special Windows driver - eisuu + Control; Japanese Solaris keyboard: kana */
    public static final int VK_KANA_LOCK                = 0x0106;

    /**
     * Constant for the input method on/off key.
     * <p>
     *  输入法开/关键的常数
     * 
     * 
     * @since 1.3
     */
    /* Japanese PC 106 keyboard: kanji. Japanese Solaris keyboard: nihongo */
    public static final int VK_INPUT_METHOD_ON_OFF      = 0x0107;

    /* for Sun keyboards */
    /** @since 1.2 */
    public static final int VK_CUT                      = 0xFFD1;
    /** @since 1.2 */
    public static final int VK_COPY                     = 0xFFCD;
    /** @since 1.2 */
    public static final int VK_PASTE                    = 0xFFCF;
    /** @since 1.2 */
    public static final int VK_UNDO                     = 0xFFCB;
    /** @since 1.2 */
    public static final int VK_AGAIN                    = 0xFFC9;
    /** @since 1.2 */
    public static final int VK_FIND                     = 0xFFD0;
    /** @since 1.2 */
    public static final int VK_PROPS                    = 0xFFCA;
    /** @since 1.2 */
    public static final int VK_STOP                     = 0xFFC8;

    /**
     * Constant for the Compose function key.
     * <p>
     *  Compose功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_COMPOSE                  = 0xFF20;

    /**
     * Constant for the AltGraph function key.
     * <p>
     *  AltGraph功能键的常量
     * 
     * 
     * @since 1.2
     */
    public static final int VK_ALT_GRAPH                = 0xFF7E;

    /**
     * Constant for the Begin key.
     * <p>
     *  开始键的常量
     * 
     * 
     * @since 1.5
     */
    public static final int VK_BEGIN                    = 0xFF58;

    /**
     * This value is used to indicate that the keyCode is unknown.
     * KEY_TYPED events do not have a keyCode value; this value
     * is used instead.
     * <p>
     *  此值用于指示keyCode未知,KEY_TYPED事件没有keyCode值;将使用此值
     * 
     */
    public static final int VK_UNDEFINED      = 0x0;

    /**
     * KEY_PRESSED and KEY_RELEASED events which do not map to a
     * valid Unicode character use this for the keyChar value.
     * <p>
     *  未映射到有效Unicode字符的KEY_PRESSED和KEY_RELEASED事件使用此keyChar值
     * 
     */
    public static final char CHAR_UNDEFINED   = 0xFFFF;

    /**
     * A constant indicating that the keyLocation is indeterminate
     * or not relevant.
     * <code>KEY_TYPED</code> events do not have a keyLocation; this value
     * is used instead.
     * <p>
     *  一个常数,指示keyLocation是不确定的或不相关的<code> KEY_TYPED </code>事件没有keyLocation;将使用此值
     * 
     * 
     * @since 1.4
     */
    public static final int KEY_LOCATION_UNKNOWN  = 0;

    /**
     * A constant indicating that the key pressed or released
     * is not distinguished as the left or right version of a key,
     * and did not originate on the numeric keypad (or did not
     * originate with a virtual key corresponding to the numeric
     * keypad).
     * <p>
     * 指示按下或释放的键不被区分为键的左或右版本,并且不是在数字键盘上发起(或者不是利用与数字键盘相对应的虚拟键)的常数,
     * 
     * 
     * @since 1.4
     */
    public static final int KEY_LOCATION_STANDARD = 1;

    /**
     * A constant indicating that the key pressed or released is in
     * the left key location (there is more than one possible location
     * for this key).  Example: the left shift key.
     * <p>
     *  指示按下或释放键的常数在左键位置(该键有多个可能的位置)示例：左移键
     * 
     * 
     * @since 1.4
     */
    public static final int KEY_LOCATION_LEFT     = 2;

    /**
     * A constant indicating that the key pressed or released is in
     * the right key location (there is more than one possible location
     * for this key).  Example: the right shift key.
     * <p>
     *  指示按下或释放的键位于右键位置的常数(此键有多个可能的位置)示例：右移键
     * 
     * 
     * @since 1.4
     */
    public static final int KEY_LOCATION_RIGHT    = 3;

    /**
     * A constant indicating that the key event originated on the
     * numeric keypad or with a virtual key corresponding to the
     * numeric keypad.
     * <p>
     *  指示键事件源于数字键盘或与数字键盘相对应的虚拟键的常数
     * 
     * 
     * @since 1.4
     */
    public static final int KEY_LOCATION_NUMPAD   = 4;

    /**
     * The unique value assigned to each of the keys on the
     * keyboard.  There is a common set of key codes that
     * can be fired by most keyboards.
     * The symbolic name for a key code should be used rather
     * than the code value itself.
     *
     * <p>
     * 分配给键盘上每个键的唯一值有大多数键盘可以触发的一组常用键代码应该使用键代码的符号名称,而不是代码值本身
     * 
     * 
     * @serial
     * @see #getKeyCode()
     * @see #setKeyCode(int)
     */
    int  keyCode;

    /**
     * <code>keyChar</code> is a valid unicode character
     * that is fired by a key or a key combination on
     * a keyboard.
     *
     * <p>
     *  <code> keyChar </code>是由键盘或键盘上的组合键触发的有效Unicode字符
     * 
     * 
     * @serial
     * @see #getKeyChar()
     * @see #setKeyChar(char)
     */
    char keyChar;

    /**
     * The location of the key on the keyboard.
     *
     * Some keys occur more than once on a keyboard, e.g. the left and
     * right shift keys.  Additionally, some keys occur on the numeric
     * keypad.  This variable is used to distinguish such keys.
     *
     * The only legal values are <code>KEY_LOCATION_UNKNOWN</code>,
     * <code>KEY_LOCATION_STANDARD</code>, <code>KEY_LOCATION_LEFT</code>,
     * <code>KEY_LOCATION_RIGHT</code>, and <code>KEY_LOCATION_NUMPAD</code>.
     *
     * <p>
     *  键盘上键的位置
     * 
     *  一些键在键盘上出现多次,例如,左和右Shift键。此外,一些键出现在数字键盘上此变量用于区分这些键
     * 
     *  唯一的合法值是<code> KEY_LOCATION_UNKNOWN </code>,<code> KEY_LOCATION_STANDARD </code>,<code> KEY_LOCATION_
     * LEFT </code>,<code> KEY_LOCATION_RIGHT </code>和<code> KEY_LOCATION_NUMPAD </code>。
     * 
     * 
     * @serial
     * @see #getKeyLocation()
     */
    int keyLocation;

    //set from native code.
    private transient long rawCode = 0;
    private transient long primaryLevelUnicode = 0;
    private transient long scancode = 0; // for MS Windows only
    private transient long extendedKeyCode = 0;

    /*
     * JDK 1.1 serialVersionUID
     * <p>
     *  JDK 11 serialVersionUID
     * 
     */
    private static final long serialVersionUID = -2352130953028126954L;

    static {
        /* ensure that the necessary native libraries are loaded */
        NativeLibLoader.loadLibraries();
        if (!GraphicsEnvironment.isHeadless()) {
            initIDs();
        }

        AWTAccessor.setKeyEventAccessor(
            new AWTAccessor.KeyEventAccessor() {
                public void setRawCode(KeyEvent ev, long rawCode) {
                    ev.rawCode = rawCode;
                }

                public void setPrimaryLevelUnicode(KeyEvent ev,
                                                   long primaryLevelUnicode) {
                    ev.primaryLevelUnicode = primaryLevelUnicode;
                }

                public void setExtendedKeyCode(KeyEvent ev,
                                               long extendedKeyCode) {
                    ev.extendedKeyCode = extendedKeyCode;
                }

                public Component getOriginalSource( KeyEvent ev ) {
                    return ev.originalSource;
                }
            });
    }

    /**
     * Initialize JNI field and method IDs for fields that may be
     * accessed from C.
     * <p>
     * 初始化可从C访问的字段的JNI字段和方法ID
     * 
     */
    private static native void initIDs();

    /**
     * The original event source.
     *
     * Event source can be changed during processing, but in some cases
     * we need to be able to obtain original source.
     * <p>
     *  原始事件源
     * 
     *  事件源可以在处理期间更改,但在某些情况下,我们需要能够获取原始源
     * 
     */
    private Component originalSource;

    private KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode, char keyChar, int keyLocation, boolean isProxyActive) {
        this(source, id, when, modifiers, keyCode, keyChar, keyLocation);
        this.isProxyActive = isProxyActive;
    }

    /**
     * Constructs a <code>KeyEvent</code> object.
     * <p>This method throws an
     * <code>IllegalArgumentException</code> if <code>source</code>
     * is <code>null</code>.
     *
     * <p>
     *  构造<code> KeyEvent </code>对象<p>如果<code>源</code>是<code> null </code>,此方法会抛出<code> IllegalArgumentExcep
     * tion </code>。
     * 
     * 
     * @param source    The <code>Component</code> that originated the event
     * @param id              An integer indicating the type of event.
     *                  For information on allowable values, see
     *                  the class description for {@link KeyEvent}
     * @param when      A long integer that specifies the time the event
     *                  occurred.
     *                     Passing negative or zero value
     *                     is not recommended
     * @param modifiers The modifier keys down during event (shift, ctrl,
     *                  alt, meta).
     *                     Passing negative value
     *                     is not recommended.
     *                     Zero value means that no modifiers were passed.
     *                  Use either an extended _DOWN_MASK or old _MASK modifiers,
     *                  however do not mix models in the one event.
     *                  The extended modifiers are preferred for using
     * @param keyCode   The integer code for an actual key, or VK_UNDEFINED
     *                  (for a key-typed event)
     * @param keyChar   The Unicode character generated by this event, or
     *                  CHAR_UNDEFINED (for key-pressed and key-released
     *                  events which do not map to a valid Unicode character)
     * @param keyLocation  Identifies the key location.  The only legal
     *        values are <code>KEY_LOCATION_UNKNOWN</code>,
     *        <code>KEY_LOCATION_STANDARD</code>, <code>KEY_LOCATION_LEFT</code>,
     *        <code>KEY_LOCATION_RIGHT</code>, and <code>KEY_LOCATION_NUMPAD</code>.
     * @throws IllegalArgumentException
     *     if <code>id</code> is <code>KEY_TYPED</code> and
     *       <code>keyChar</code> is <code>CHAR_UNDEFINED</code>;
     *     or if <code>id</code> is <code>KEY_TYPED</code> and
     *       <code>keyCode</code> is not <code>VK_UNDEFINED</code>;
     *     or if <code>id</code> is <code>KEY_TYPED</code> and
     *       <code>keyLocation</code> is not <code>KEY_LOCATION_UNKNOWN</code>;
     *     or if <code>keyLocation</code> is not one of the legal
     *       values enumerated above.
     * @throws IllegalArgumentException if <code>source</code> is null
     * @see #getSource()
     * @see #getID()
     * @see #getWhen()
     * @see #getModifiers()
     * @see #getKeyCode()
     * @see #getKeyChar()
     * @see #getKeyLocation()
     * @since 1.4
     */
    public KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode, char keyChar, int keyLocation) {
        super(source, id, when, modifiers);
        if (id == KEY_TYPED) {
            if (keyChar == CHAR_UNDEFINED) {
                throw new IllegalArgumentException("invalid keyChar");
            }
            if (keyCode != VK_UNDEFINED) {
                throw new IllegalArgumentException("invalid keyCode");
            }
            if (keyLocation != KEY_LOCATION_UNKNOWN) {
                throw new IllegalArgumentException("invalid keyLocation");
            }
        }

        this.keyCode = keyCode;
        this.keyChar = keyChar;

        if ((keyLocation < KEY_LOCATION_UNKNOWN) ||
            (keyLocation > KEY_LOCATION_NUMPAD)) {
            throw new IllegalArgumentException("invalid keyLocation");
        }
        this.keyLocation = keyLocation;
        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {
            setNewModifiers();
        } else if ((getModifiers() == 0) && (getModifiersEx() != 0)) {
            setOldModifiers();
        }
        originalSource = source;
    }

    /**
     * Constructs a <code>KeyEvent</code> object.
     * <p> This method throws an
     * <code>IllegalArgumentException</code> if <code>source</code>
     * is <code>null</code>.
     *
     * <p>
     *  构造<code> KeyEvent </code>对象<p>如果<code>源</code>是<code> null </code>,此方法会抛出<code> IllegalArgumentExcep
     * tion </code>。
     * 
     * 
     * @param source    The <code>Component</code> that originated the event
     * @param id              An integer indicating the type of event.
     *                  For information on allowable values, see
     *                  the class description for {@link KeyEvent}
     * @param when      A long integer that specifies the time the event
     *                  occurred.
     *                     Passing negative or zero value
     *                     is not recommended
     * @param modifiers The modifier keys down during event (shift, ctrl,
     *                  alt, meta).
     *                     Passing negative value
     *                     is not recommended.
     *                     Zero value means that no modifiers were passed.
     *                  Use either an extended _DOWN_MASK or old _MASK modifiers,
     *                  however do not mix models in the one event.
     *                  The extended modifiers are preferred for using
     * @param keyCode   The integer code for an actual key, or VK_UNDEFINED
     *                  (for a key-typed event)
     * @param keyChar   The Unicode character generated by this event, or
     *                  CHAR_UNDEFINED (for key-pressed and key-released
     *                  events which do not map to a valid Unicode character)
     * @throws IllegalArgumentException  if <code>id</code> is
     *     <code>KEY_TYPED</code> and <code>keyChar</code> is
     *     <code>CHAR_UNDEFINED</code>; or if <code>id</code> is
     *     <code>KEY_TYPED</code> and <code>keyCode</code> is not
     *     <code>VK_UNDEFINED</code>
     * @throws IllegalArgumentException if <code>source</code> is null
     * @see #getSource()
     * @see #getID()
     * @see #getWhen()
     * @see #getModifiers()
     * @see #getKeyCode()
     * @see #getKeyChar()
     */
    public KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode, char keyChar) {
        this(source, id, when, modifiers, keyCode, keyChar,
          KEY_LOCATION_UNKNOWN);
    }

    /**
    /* <p>
    /* 
     * @deprecated as of JDK1.1
     */
    @Deprecated
    public KeyEvent(Component source, int id, long when, int modifiers,
                    int keyCode) {
        this(source, id, when, modifiers, keyCode, (char)keyCode);
    }

    /**
     * Returns the integer keyCode associated with the key in this event.
     *
     * <p>
     *  返回与此事件中的键相关联的整数keyCode
     * 
     * 
     * @return the integer code for an actual key on the keyboard.
     *         (For <code>KEY_TYPED</code> events, the keyCode is
     *         <code>VK_UNDEFINED</code>.)
     */
    public int getKeyCode() {
        return keyCode;
    }

    /**
     * Set the keyCode value to indicate a physical key.
     *
     * <p>
     *  设置keyCode值以指示物理键
     * 
     * 
     * @param keyCode an integer corresponding to an actual key on the keyboard.
     */
    public void setKeyCode(int keyCode) {
        this.keyCode = keyCode;
    }

    /**
     * Returns the character associated with the key in this event.
     * For example, the <code>KEY_TYPED</code> event for shift + "a"
     * returns the value for "A".
     * <p>
     * <code>KEY_PRESSED</code> and <code>KEY_RELEASED</code> events
     * are not intended for reporting of character input.  Therefore,
     * the values returned by this method are guaranteed to be
     * meaningful only for <code>KEY_TYPED</code> events.
     *
     * <p>
     *  返回与此事件中的键相关联的字符例如,shift +"a"的<code> KEY_TYPED </code>事件返回"A"
     * <p>
     * <code> KEY_PRESSED </code>和<code> KEY_RELEASED </code>事件不适用于报告字符输入因此,此方法返回的值仅在<code> KEY_TYPED </code>
     * 事件。
     * 
     * 
     * @return the Unicode character defined for this key event.
     *         If no valid Unicode character exists for this key event,
     *         <code>CHAR_UNDEFINED</code> is returned.
     */
    public char getKeyChar() {
        return keyChar;
    }

    /**
     * Set the keyChar value to indicate a logical character.
     *
     * <p>
     *  设置keyChar值以指示逻辑字符
     * 
     * 
     * @param keyChar a char corresponding to to the combination of keystrokes
     *                that make up this event.
     */
    public void setKeyChar(char keyChar) {
        this.keyChar = keyChar;
    }

    /**
     * Set the modifiers to indicate additional keys that were held down
     * (e.g. shift, ctrl, alt, meta) defined as part of InputEvent.
     * <p>
     * NOTE:  use of this method is not recommended, because many AWT
     * implementations do not recognize modifier changes.  This is
     * especially true for <code>KEY_TYPED</code> events where the shift
     * modifier is changed.
     *
     * <p>
     *  设置修饰符以指示按住的附加键(例如shift,ctrl,alt,meta),定义为InputEvent的一部分
     * <p>
     *  注意：不建议使用此方法,因为许多AWT实现不识别修饰符更改这对于更改了shift修饰符的<code> KEY_TYPED </code>事件尤其如此
     * 
     * 
     * @param modifiers an integer combination of the modifier constants.
     * @see InputEvent
     * @deprecated as of JDK1.1.4
     */
    @Deprecated
    public void setModifiers(int modifiers) {
        this.modifiers = modifiers;
        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {
            setNewModifiers();
        } else if ((getModifiers() == 0) && (getModifiersEx() != 0)) {
            setOldModifiers();
        }
    }

    /**
     * Returns the location of the key that originated this key event.
     *
     * Some keys occur more than once on a keyboard, e.g. the left and
     * right shift keys.  Additionally, some keys occur on the numeric
     * keypad.  This provides a way of distinguishing such keys.
     *
     * <p>
     *  返回发生此键事件的键的位置
     * 
     * 一些键在键盘上出现多次,例如左和右Shift键。此外,一些键出现在数字键盘上这提供了区分这些键的方式
     * 
     * 
     * @return the location of the key that was pressed or released.
     *         Always returns <code>KEY_LOCATION_UNKNOWN</code> for
     *         <code>KEY_TYPED</code> events.
     * @since 1.4
     */
    public int getKeyLocation() {
        return keyLocation;
    }

    /**
     * Returns a String describing the keyCode, such as "HOME", "F1" or "A".
     * These strings can be localized by changing the awt.properties file.
     *
     * <p>
     *  返回描述keyCode的字符串,例如"HOME","F1"或"A"这些字符串可以通过更改awtproperties文件
     * 
     * 
     * @return a string containing a text description for a physical key,
     *         identified by its keyCode
     */
    public static String getKeyText(int keyCode) {
        if (keyCode >= VK_0 && keyCode <= VK_9 ||
            keyCode >= VK_A && keyCode <= VK_Z) {
            return String.valueOf((char)keyCode);
        }

        switch(keyCode) {
          case VK_ENTER: return Toolkit.getProperty("AWT.enter", "Enter");
          case VK_BACK_SPACE: return Toolkit.getProperty("AWT.backSpace", "Backspace");
          case VK_TAB: return Toolkit.getProperty("AWT.tab", "Tab");
          case VK_CANCEL: return Toolkit.getProperty("AWT.cancel", "Cancel");
          case VK_CLEAR: return Toolkit.getProperty("AWT.clear", "Clear");
          case VK_COMPOSE: return Toolkit.getProperty("AWT.compose", "Compose");
          case VK_PAUSE: return Toolkit.getProperty("AWT.pause", "Pause");
          case VK_CAPS_LOCK: return Toolkit.getProperty("AWT.capsLock", "Caps Lock");
          case VK_ESCAPE: return Toolkit.getProperty("AWT.escape", "Escape");
          case VK_SPACE: return Toolkit.getProperty("AWT.space", "Space");
          case VK_PAGE_UP: return Toolkit.getProperty("AWT.pgup", "Page Up");
          case VK_PAGE_DOWN: return Toolkit.getProperty("AWT.pgdn", "Page Down");
          case VK_END: return Toolkit.getProperty("AWT.end", "End");
          case VK_HOME: return Toolkit.getProperty("AWT.home", "Home");
          case VK_LEFT: return Toolkit.getProperty("AWT.left", "Left");
          case VK_UP: return Toolkit.getProperty("AWT.up", "Up");
          case VK_RIGHT: return Toolkit.getProperty("AWT.right", "Right");
          case VK_DOWN: return Toolkit.getProperty("AWT.down", "Down");
          case VK_BEGIN: return Toolkit.getProperty("AWT.begin", "Begin");

          // modifiers
          case VK_SHIFT: return Toolkit.getProperty("AWT.shift", "Shift");
          case VK_CONTROL: return Toolkit.getProperty("AWT.control", "Control");
          case VK_ALT: return Toolkit.getProperty("AWT.alt", "Alt");
          case VK_META: return Toolkit.getProperty("AWT.meta", "Meta");
          case VK_ALT_GRAPH: return Toolkit.getProperty("AWT.altGraph", "Alt Graph");

          // punctuation
          case VK_COMMA: return Toolkit.getProperty("AWT.comma", "Comma");
          case VK_PERIOD: return Toolkit.getProperty("AWT.period", "Period");
          case VK_SLASH: return Toolkit.getProperty("AWT.slash", "Slash");
          case VK_SEMICOLON: return Toolkit.getProperty("AWT.semicolon", "Semicolon");
          case VK_EQUALS: return Toolkit.getProperty("AWT.equals", "Equals");
          case VK_OPEN_BRACKET: return Toolkit.getProperty("AWT.openBracket", "Open Bracket");
          case VK_BACK_SLASH: return Toolkit.getProperty("AWT.backSlash", "Back Slash");
          case VK_CLOSE_BRACKET: return Toolkit.getProperty("AWT.closeBracket", "Close Bracket");

          // numpad numeric keys handled below
          case VK_MULTIPLY: return Toolkit.getProperty("AWT.multiply", "NumPad *");
          case VK_ADD: return Toolkit.getProperty("AWT.add", "NumPad +");
          case VK_SEPARATOR: return Toolkit.getProperty("AWT.separator", "NumPad ,");
          case VK_SUBTRACT: return Toolkit.getProperty("AWT.subtract", "NumPad -");
          case VK_DECIMAL: return Toolkit.getProperty("AWT.decimal", "NumPad .");
          case VK_DIVIDE: return Toolkit.getProperty("AWT.divide", "NumPad /");
          case VK_DELETE: return Toolkit.getProperty("AWT.delete", "Delete");
          case VK_NUM_LOCK: return Toolkit.getProperty("AWT.numLock", "Num Lock");
          case VK_SCROLL_LOCK: return Toolkit.getProperty("AWT.scrollLock", "Scroll Lock");

          case VK_WINDOWS: return Toolkit.getProperty("AWT.windows", "Windows");
          case VK_CONTEXT_MENU: return Toolkit.getProperty("AWT.context", "Context Menu");

          case VK_F1: return Toolkit.getProperty("AWT.f1", "F1");
          case VK_F2: return Toolkit.getProperty("AWT.f2", "F2");
          case VK_F3: return Toolkit.getProperty("AWT.f3", "F3");
          case VK_F4: return Toolkit.getProperty("AWT.f4", "F4");
          case VK_F5: return Toolkit.getProperty("AWT.f5", "F5");
          case VK_F6: return Toolkit.getProperty("AWT.f6", "F6");
          case VK_F7: return Toolkit.getProperty("AWT.f7", "F7");
          case VK_F8: return Toolkit.getProperty("AWT.f8", "F8");
          case VK_F9: return Toolkit.getProperty("AWT.f9", "F9");
          case VK_F10: return Toolkit.getProperty("AWT.f10", "F10");
          case VK_F11: return Toolkit.getProperty("AWT.f11", "F11");
          case VK_F12: return Toolkit.getProperty("AWT.f12", "F12");
          case VK_F13: return Toolkit.getProperty("AWT.f13", "F13");
          case VK_F14: return Toolkit.getProperty("AWT.f14", "F14");
          case VK_F15: return Toolkit.getProperty("AWT.f15", "F15");
          case VK_F16: return Toolkit.getProperty("AWT.f16", "F16");
          case VK_F17: return Toolkit.getProperty("AWT.f17", "F17");
          case VK_F18: return Toolkit.getProperty("AWT.f18", "F18");
          case VK_F19: return Toolkit.getProperty("AWT.f19", "F19");
          case VK_F20: return Toolkit.getProperty("AWT.f20", "F20");
          case VK_F21: return Toolkit.getProperty("AWT.f21", "F21");
          case VK_F22: return Toolkit.getProperty("AWT.f22", "F22");
          case VK_F23: return Toolkit.getProperty("AWT.f23", "F23");
          case VK_F24: return Toolkit.getProperty("AWT.f24", "F24");

          case VK_PRINTSCREEN: return Toolkit.getProperty("AWT.printScreen", "Print Screen");
          case VK_INSERT: return Toolkit.getProperty("AWT.insert", "Insert");
          case VK_HELP: return Toolkit.getProperty("AWT.help", "Help");
          case VK_BACK_QUOTE: return Toolkit.getProperty("AWT.backQuote", "Back Quote");
          case VK_QUOTE: return Toolkit.getProperty("AWT.quote", "Quote");

          case VK_KP_UP: return Toolkit.getProperty("AWT.up", "Up");
          case VK_KP_DOWN: return Toolkit.getProperty("AWT.down", "Down");
          case VK_KP_LEFT: return Toolkit.getProperty("AWT.left", "Left");
          case VK_KP_RIGHT: return Toolkit.getProperty("AWT.right", "Right");

          case VK_DEAD_GRAVE: return Toolkit.getProperty("AWT.deadGrave", "Dead Grave");
          case VK_DEAD_ACUTE: return Toolkit.getProperty("AWT.deadAcute", "Dead Acute");
          case VK_DEAD_CIRCUMFLEX: return Toolkit.getProperty("AWT.deadCircumflex", "Dead Circumflex");
          case VK_DEAD_TILDE: return Toolkit.getProperty("AWT.deadTilde", "Dead Tilde");
          case VK_DEAD_MACRON: return Toolkit.getProperty("AWT.deadMacron", "Dead Macron");
          case VK_DEAD_BREVE: return Toolkit.getProperty("AWT.deadBreve", "Dead Breve");
          case VK_DEAD_ABOVEDOT: return Toolkit.getProperty("AWT.deadAboveDot", "Dead Above Dot");
          case VK_DEAD_DIAERESIS: return Toolkit.getProperty("AWT.deadDiaeresis", "Dead Diaeresis");
          case VK_DEAD_ABOVERING: return Toolkit.getProperty("AWT.deadAboveRing", "Dead Above Ring");
          case VK_DEAD_DOUBLEACUTE: return Toolkit.getProperty("AWT.deadDoubleAcute", "Dead Double Acute");
          case VK_DEAD_CARON: return Toolkit.getProperty("AWT.deadCaron", "Dead Caron");
          case VK_DEAD_CEDILLA: return Toolkit.getProperty("AWT.deadCedilla", "Dead Cedilla");
          case VK_DEAD_OGONEK: return Toolkit.getProperty("AWT.deadOgonek", "Dead Ogonek");
          case VK_DEAD_IOTA: return Toolkit.getProperty("AWT.deadIota", "Dead Iota");
          case VK_DEAD_VOICED_SOUND: return Toolkit.getProperty("AWT.deadVoicedSound", "Dead Voiced Sound");
          case VK_DEAD_SEMIVOICED_SOUND: return Toolkit.getProperty("AWT.deadSemivoicedSound", "Dead Semivoiced Sound");

          case VK_AMPERSAND: return Toolkit.getProperty("AWT.ampersand", "Ampersand");
          case VK_ASTERISK: return Toolkit.getProperty("AWT.asterisk", "Asterisk");
          case VK_QUOTEDBL: return Toolkit.getProperty("AWT.quoteDbl", "Double Quote");
          case VK_LESS: return Toolkit.getProperty("AWT.Less", "Less");
          case VK_GREATER: return Toolkit.getProperty("AWT.greater", "Greater");
          case VK_BRACELEFT: return Toolkit.getProperty("AWT.braceLeft", "Left Brace");
          case VK_BRACERIGHT: return Toolkit.getProperty("AWT.braceRight", "Right Brace");
          case VK_AT: return Toolkit.getProperty("AWT.at", "At");
          case VK_COLON: return Toolkit.getProperty("AWT.colon", "Colon");
          case VK_CIRCUMFLEX: return Toolkit.getProperty("AWT.circumflex", "Circumflex");
          case VK_DOLLAR: return Toolkit.getProperty("AWT.dollar", "Dollar");
          case VK_EURO_SIGN: return Toolkit.getProperty("AWT.euro", "Euro");
          case VK_EXCLAMATION_MARK: return Toolkit.getProperty("AWT.exclamationMark", "Exclamation Mark");
          case VK_INVERTED_EXCLAMATION_MARK: return Toolkit.getProperty("AWT.invertedExclamationMark", "Inverted Exclamation Mark");
          case VK_LEFT_PARENTHESIS: return Toolkit.getProperty("AWT.leftParenthesis", "Left Parenthesis");
          case VK_NUMBER_SIGN: return Toolkit.getProperty("AWT.numberSign", "Number Sign");
          case VK_MINUS: return Toolkit.getProperty("AWT.minus", "Minus");
          case VK_PLUS: return Toolkit.getProperty("AWT.plus", "Plus");
          case VK_RIGHT_PARENTHESIS: return Toolkit.getProperty("AWT.rightParenthesis", "Right Parenthesis");
          case VK_UNDERSCORE: return Toolkit.getProperty("AWT.underscore", "Underscore");

          case VK_FINAL: return Toolkit.getProperty("AWT.final", "Final");
          case VK_CONVERT: return Toolkit.getProperty("AWT.convert", "Convert");
          case VK_NONCONVERT: return Toolkit.getProperty("AWT.noconvert", "No Convert");
          case VK_ACCEPT: return Toolkit.getProperty("AWT.accept", "Accept");
          case VK_MODECHANGE: return Toolkit.getProperty("AWT.modechange", "Mode Change");
          case VK_KANA: return Toolkit.getProperty("AWT.kana", "Kana");
          case VK_KANJI: return Toolkit.getProperty("AWT.kanji", "Kanji");
          case VK_ALPHANUMERIC: return Toolkit.getProperty("AWT.alphanumeric", "Alphanumeric");
          case VK_KATAKANA: return Toolkit.getProperty("AWT.katakana", "Katakana");
          case VK_HIRAGANA: return Toolkit.getProperty("AWT.hiragana", "Hiragana");
          case VK_FULL_WIDTH: return Toolkit.getProperty("AWT.fullWidth", "Full-Width");
          case VK_HALF_WIDTH: return Toolkit.getProperty("AWT.halfWidth", "Half-Width");
          case VK_ROMAN_CHARACTERS: return Toolkit.getProperty("AWT.romanCharacters", "Roman Characters");
          case VK_ALL_CANDIDATES: return Toolkit.getProperty("AWT.allCandidates", "All Candidates");
          case VK_PREVIOUS_CANDIDATE: return Toolkit.getProperty("AWT.previousCandidate", "Previous Candidate");
          case VK_CODE_INPUT: return Toolkit.getProperty("AWT.codeInput", "Code Input");
          case VK_JAPANESE_KATAKANA: return Toolkit.getProperty("AWT.japaneseKatakana", "Japanese Katakana");
          case VK_JAPANESE_HIRAGANA: return Toolkit.getProperty("AWT.japaneseHiragana", "Japanese Hiragana");
          case VK_JAPANESE_ROMAN: return Toolkit.getProperty("AWT.japaneseRoman", "Japanese Roman");
          case VK_KANA_LOCK: return Toolkit.getProperty("AWT.kanaLock", "Kana Lock");
          case VK_INPUT_METHOD_ON_OFF: return Toolkit.getProperty("AWT.inputMethodOnOff", "Input Method On/Off");

          case VK_AGAIN: return Toolkit.getProperty("AWT.again", "Again");
          case VK_UNDO: return Toolkit.getProperty("AWT.undo", "Undo");
          case VK_COPY: return Toolkit.getProperty("AWT.copy", "Copy");
          case VK_PASTE: return Toolkit.getProperty("AWT.paste", "Paste");
          case VK_CUT: return Toolkit.getProperty("AWT.cut", "Cut");
          case VK_FIND: return Toolkit.getProperty("AWT.find", "Find");
          case VK_PROPS: return Toolkit.getProperty("AWT.props", "Props");
          case VK_STOP: return Toolkit.getProperty("AWT.stop", "Stop");
        }

        if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9) {
            String numpad = Toolkit.getProperty("AWT.numpad", "NumPad");
            char c = (char)(keyCode - VK_NUMPAD0 + '0');
            return numpad + "-" + c;
        }

        if ((keyCode & 0x01000000) != 0) {
            return String.valueOf((char)(keyCode ^ 0x01000000 ));
        }
        String unknown = Toolkit.getProperty("AWT.unknown", "Unknown");
        return unknown + " keyCode: 0x" + Integer.toString(keyCode, 16);
    }

    /**
     * Returns a <code>String</code> describing the modifier key(s),
     * such as "Shift", or "Ctrl+Shift".  These strings can be
     * localized by changing the <code>awt.properties</code> file.
     * <p>
     * Note that <code>InputEvent.ALT_MASK</code> and
     * <code>InputEvent.BUTTON2_MASK</code> have the same value,
     * so the string "Alt" is returned for both modifiers.  Likewise,
     * <code>InputEvent.META_MASK</code> and
     * <code>InputEvent.BUTTON3_MASK</code> have the same value,
     * so the string "Meta" is returned for both modifiers.
     *
     * <p>
     *  返回描述修饰符键(例如"Shift"或"Ctrl + Shift")的<code> String </code>这些字符串可以通过更改<code> awtproperties </code>文件
     * <p>
     * 请注意,<code> InputEventALT_MASK </code>和<code> InputEventBUTTON2_MASK </code>具有相同的值,因此为两个修饰符返回字符串"Alt"同
     * 样,<code> InputEventMETA_MASK </code>和<code> InputEventBUTTON3_MASK </code>具有相同的值,因此为两个修饰符返回字符串"Meta"。
     * 
     * 
     * @return string a text description of the combination of modifier
     *                keys that were held down during the event
     * @see InputEvent#getModifiersExText(int)
     */
    public static String getKeyModifiersText(int modifiers) {
        StringBuilder buf = new StringBuilder();
        if ((modifiers & InputEvent.META_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.meta", "Meta"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.CTRL_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.control", "Ctrl"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.ALT_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.alt", "Alt"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.SHIFT_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.shift", "Shift"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.ALT_GRAPH_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.altGraph", "Alt Graph"));
            buf.append("+");
        }
        if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {
            buf.append(Toolkit.getProperty("AWT.button1", "Button1"));
            buf.append("+");
        }
        if (buf.length() > 0) {
            buf.setLength(buf.length()-1); // remove trailing '+'
        }
        return buf.toString();
    }


    /**
     * Returns whether the key in this event is an "action" key.
     * Typically an action key does not fire a unicode character and is
     * not a modifier key.
     *
     * <p>
     *  返回此事件中的键是否为"action"键通常,操作键不会触发unicode字符,而不是修饰键
     * 
     * 
     * @return <code>true</code> if the key is an "action" key,
     *         <code>false</code> otherwise
     */
    public boolean isActionKey() {
        switch (keyCode) {
          case VK_HOME:
          case VK_END:
          case VK_PAGE_UP:
          case VK_PAGE_DOWN:
          case VK_UP:
          case VK_DOWN:
          case VK_LEFT:
          case VK_RIGHT:
          case VK_BEGIN:

          case VK_KP_LEFT:
          case VK_KP_UP:
          case VK_KP_RIGHT:
          case VK_KP_DOWN:

          case VK_F1:
          case VK_F2:
          case VK_F3:
          case VK_F4:
          case VK_F5:
          case VK_F6:
          case VK_F7:
          case VK_F8:
          case VK_F9:
          case VK_F10:
          case VK_F11:
          case VK_F12:
          case VK_F13:
          case VK_F14:
          case VK_F15:
          case VK_F16:
          case VK_F17:
          case VK_F18:
          case VK_F19:
          case VK_F20:
          case VK_F21:
          case VK_F22:
          case VK_F23:
          case VK_F24:
          case VK_PRINTSCREEN:
          case VK_SCROLL_LOCK:
          case VK_CAPS_LOCK:
          case VK_NUM_LOCK:
          case VK_PAUSE:
          case VK_INSERT:

          case VK_FINAL:
          case VK_CONVERT:
          case VK_NONCONVERT:
          case VK_ACCEPT:
          case VK_MODECHANGE:
          case VK_KANA:
          case VK_KANJI:
          case VK_ALPHANUMERIC:
          case VK_KATAKANA:
          case VK_HIRAGANA:
          case VK_FULL_WIDTH:
          case VK_HALF_WIDTH:
          case VK_ROMAN_CHARACTERS:
          case VK_ALL_CANDIDATES:
          case VK_PREVIOUS_CANDIDATE:
          case VK_CODE_INPUT:
          case VK_JAPANESE_KATAKANA:
          case VK_JAPANESE_HIRAGANA:
          case VK_JAPANESE_ROMAN:
          case VK_KANA_LOCK:
          case VK_INPUT_METHOD_ON_OFF:

          case VK_AGAIN:
          case VK_UNDO:
          case VK_COPY:
          case VK_PASTE:
          case VK_CUT:
          case VK_FIND:
          case VK_PROPS:
          case VK_STOP:

          case VK_HELP:
          case VK_WINDOWS:
          case VK_CONTEXT_MENU:
              return true;
        }
        return false;
    }

    /**
     * Returns a parameter string identifying this event.
     * This method is useful for event logging and for debugging.
     *
     * <p>
     *  返回标识此事件的参数字符串此方法对于事件日志记录和调试非常有用
     * 
     * 
     * @return a string identifying the event and its attributes
     */
    public String paramString() {
        StringBuilder str = new StringBuilder(100);

        switch (id) {
          case KEY_PRESSED:
            str.append("KEY_PRESSED");
            break;
          case KEY_RELEASED:
            str.append("KEY_RELEASED");
            break;
          case KEY_TYPED:
            str.append("KEY_TYPED");
            break;
          default:
            str.append("unknown type");
            break;
        }

        str.append(",keyCode=").append(keyCode);
        str.append(",keyText=").append(getKeyText(keyCode));

        /* Some keychars don't print well, e.g. escape, backspace,
         * tab, return, delete, cancel.  Get keyText for the keyCode
         * instead of the keyChar.
         * <p>
         *  tab,return,delete,cancel获取keyCode的keyText,而不是keyChar
         * 
         */
        str.append(",keyChar=");
        switch (keyChar) {
          case '\b':
            str.append(getKeyText(VK_BACK_SPACE));
            break;
          case '\t':
            str.append(getKeyText(VK_TAB));
            break;
          case '\n':
            str.append(getKeyText(VK_ENTER));
            break;
          case '\u0018':
            str.append(getKeyText(VK_CANCEL));
            break;
          case '\u001b':
            str.append(getKeyText(VK_ESCAPE));
            break;
          case '\u007f':
            str.append(getKeyText(VK_DELETE));
            break;
          case CHAR_UNDEFINED:
            str.append(Toolkit.getProperty("AWT.undefined", "Undefined"));
            str.append(" keyChar");
            break;
          default:
            str.append("'").append(keyChar).append("'");
            break;
        }

        if (getModifiers() != 0) {
            str.append(",modifiers=").append(getKeyModifiersText(modifiers));
        }
        if (getModifiersEx() != 0) {
            str.append(",extModifiers=").append(getModifiersExText(modifiers));
        }

        str.append(",keyLocation=");
        switch (keyLocation) {
          case KEY_LOCATION_UNKNOWN:
            str.append("KEY_LOCATION_UNKNOWN");
            break;
          case KEY_LOCATION_STANDARD:
            str.append("KEY_LOCATION_STANDARD");
            break;
          case KEY_LOCATION_LEFT:
            str.append("KEY_LOCATION_LEFT");
            break;
          case KEY_LOCATION_RIGHT:
            str.append("KEY_LOCATION_RIGHT");
            break;
          case KEY_LOCATION_NUMPAD:
            str.append("KEY_LOCATION_NUMPAD");
            break;
          default:
            str.append("KEY_LOCATION_UNKNOWN");
            break;
        }
        str.append(",rawCode=").append(rawCode);
        str.append(",primaryLevelUnicode=").append(primaryLevelUnicode);
        str.append(",scancode=").append(scancode);
        str.append(",extendedKeyCode=0x").append(Long.toHexString(extendedKeyCode));

        return str.toString();
    }
    /**
     * Returns an extended key code for the event.
     * The extended key code is a unique id assigned to  a key on the keyboard
     * just like {@code keyCode}. However, unlike {@code keyCode}, this value depends on the
     * current keyboard layout. For instance, pressing the left topmost letter key
     * in a common English layout produces the same value as {@code keyCode}, {@code VK_Q}.
     * Pressing the same key in a regular Russian layout gives another code, unique for the
     * letter "Cyrillic I short".
     *
     * <p>
     * 返回事件的扩展键代码扩展键代码是一个分配给键盘上的键的唯一id,就像{@code keyCode}但是,与{@code keyCode}不同,这个值取决于当前的键盘布局例如,在普通英语布局中按左最高字母
     * 键产生与{@code keyCode}相同的值,{@code VK_Q}在普通的俄语布局中按相同的键给出另一个代码,对于字母"Cyrillic I short"是唯一的,。
     * 
     * 
     * @since 1.7
     *
     */
    public  int getExtendedKeyCode() {
        return (int)extendedKeyCode;
    }
    /**
     * Returns an extended key code for a unicode character.
     *
     * <p>
     *  返回unicode字符的扩展键代码
     * 
     * 
     * @return for a unicode character with a corresponding {@code VK_} constant -- this
     *   {@code VK_} constant; for a character appearing on the primary
     *   level of a known keyboard layout -- a unique integer.
     *   If a character does not appear on the primary level of a known keyboard,
     *   {@code VK_UNDEFINED} is returned.
     *
     * @since 1.7
     *
     */
    public static int getExtendedKeyCodeForChar(int c) {
        // Return a keycode (if any) associated with a character.
        return sun.awt.ExtendedKeyCodes.getExtendedKeyCodeForChar(c);
    }

    /**
     * Sets new modifiers by the old ones. The key modifiers
     * override overlaping mouse modifiers.
     * <p>
     *  使用旧的修饰符设置新的修饰符键修饰符覆盖重叠的鼠标修饰符
     * 
     */
    private void setNewModifiers() {
        if ((modifiers & SHIFT_MASK) != 0) {
            modifiers |= SHIFT_DOWN_MASK;
        }
        if ((modifiers & ALT_MASK) != 0) {
            modifiers |= ALT_DOWN_MASK;
        }
        if ((modifiers & CTRL_MASK) != 0) {
            modifiers |= CTRL_DOWN_MASK;
        }
        if ((modifiers & META_MASK) != 0) {
            modifiers |= META_DOWN_MASK;
        }
        if ((modifiers & ALT_GRAPH_MASK) != 0) {
            modifiers |= ALT_GRAPH_DOWN_MASK;
        }
        if ((modifiers & BUTTON1_MASK) != 0) {
            modifiers |= BUTTON1_DOWN_MASK;
        }
    }

    /**
     * Sets old modifiers by the new ones.
     * <p>
     *  通过新的修饰符设置旧的修饰符
     * 
     */
    private void setOldModifiers() {
        if ((modifiers & SHIFT_DOWN_MASK) != 0) {
            modifiers |= SHIFT_MASK;
        }
        if ((modifiers & ALT_DOWN_MASK) != 0) {
            modifiers |= ALT_MASK;
        }
        if ((modifiers & CTRL_DOWN_MASK) != 0) {
            modifiers |= CTRL_MASK;
        }
        if ((modifiers & META_DOWN_MASK) != 0) {
            modifiers |= META_MASK;
        }
        if ((modifiers & ALT_GRAPH_DOWN_MASK) != 0) {
            modifiers |= ALT_GRAPH_MASK;
        }
        if ((modifiers & BUTTON1_DOWN_MASK) != 0) {
            modifiers |= BUTTON1_MASK;
        }
    }

    /**
     * Sets new modifiers by the old ones. The key modifiers
     * override overlaping mouse modifiers.
     * <p>
     *  使用旧的修饰符设置新的修饰符键修饰符覆盖重叠的鼠标修饰符
     * 
     * @serial
     */
    private void readObject(ObjectInputStream s)
      throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        if (getModifiers() != 0 && getModifiersEx() == 0) {
            setNewModifiers();
        }
    }
}
