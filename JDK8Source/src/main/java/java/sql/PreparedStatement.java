/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package java.sql;

import java.math.BigDecimal;
import java.util.Calendar;
import java.io.Reader;
import java.io.InputStream;

/**
 * An object that represents a precompiled SQL statement.
 * <P>A SQL statement is precompiled and stored in a
 * <code>PreparedStatement</code> object. This object can then be used to
 * efficiently execute this statement multiple times.
 *
 * <P><B>Note:</B> The setter methods (<code>setShort</code>, <code>setString</code>,
 * and so on) for setting IN parameter values
 * must specify types that are compatible with the defined SQL type of
 * the input parameter. For instance, if the IN parameter has SQL type
 * <code>INTEGER</code>, then the method <code>setInt</code> should be used.
 *
 * <p>If arbitrary parameter type conversions are required, the method
 * <code>setObject</code> should be used with a target SQL type.
 * <P>
 * In the following example of setting a parameter, <code>con</code> represents
 * an active connection:
 * <PRE>
 *   PreparedStatement pstmt = con.prepareStatement("UPDATE EMPLOYEES
 *                                     SET SALARY = ? WHERE ID = ?");
 *   pstmt.setBigDecimal(1, 153833.00)
 *   pstmt.setInt(2, 110592)
 * </PRE>
 *
 * <p>
 *  表示预编译的SQL语句的对象。 <P>一个SQL语句被预编译并存储在一个<code> PreparedStatement </code>对象中。然后可以使用此对象多次有效地执行此语句。
 * 
 *  <P> <B>注意：</B>用于设置IN参数值的setter方法(<code> setShort </code>,<code> setString </code>等)必须指定与定义的输入参数的SQL类
 * 型。
 * 例如,如果IN参数具有SQL类型<code> INTEGER </code>,那么应该使用方法<code> setInt </code>。
 * 
 *  <p>如果需要任意参数类型转换,方法<code> setObject </code>应与目标SQL类型一起使用。
 * <P>
 *  在以下设置参数的示例中,<code> con </code>表示活动连接：
 * <PRE>
 *  PreparedStatement pstmt = con.prepareStatement("UPDATE EMPLOYEES SET SALARY =?WHERE ID =?"); pstmt.s
 * etBigDecimal(1,153833.00)pstmt.setInt(2,110592)。
 * </PRE>
 * 
 * 
 * @see Connection#prepareStatement
 * @see ResultSet
 */

public interface PreparedStatement extends Statement {

    /**
     * Executes the SQL query in this <code>PreparedStatement</code> object
     * and returns the <code>ResultSet</code> object generated by the query.
     *
     * <p>
     *  在此<code> PreparedStatement </code>对象中执行SQL查询,并返回由查询生成的<code> ResultSet </code>对象。
     * 
     * 
     * @return a <code>ResultSet</code> object that contains the data produced by the
     *         query; never <code>null</code>
     * @exception SQLException if a database access error occurs;
     * this method is called on a closed  <code>PreparedStatement</code> or the SQL
     *            statement does not return a <code>ResultSet</code> object
     * @throws SQLTimeoutException when the driver has determined that the
     * timeout value that was specified by the {@code setQueryTimeout}
     * method has been exceeded and has at least attempted to cancel
     * the currently running {@code Statement}
     */
    ResultSet executeQuery() throws SQLException;

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code> object,
     * which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
     * <code>DELETE</code>; or an SQL statement that returns nothing,
     * such as a DDL statement.
     *
     * <p>
     * 在此<code> PreparedStatement </code>对象中执行SQL语句,该对象必须是SQL数据操作语言(DML)语句,例如<code> INSERT </code>,<code> UP
     * DATE </code>代码> DELETE </code>;或不返回任何内容的SQL语句,例如DDL语句。
     * 
     * 
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
     *         or (2) 0 for SQL statements that return nothing
     * @exception SQLException if a database access error occurs;
     * this method is called on a closed  <code>PreparedStatement</code>
     * or the SQL statement returns a <code>ResultSet</code> object
     * @throws SQLTimeoutException when the driver has determined that the
     * timeout value that was specified by the {@code setQueryTimeout}
     * method has been exceeded and has at least attempted to cancel
     * the currently running {@code Statement}
     */
    int executeUpdate() throws SQLException;

    /**
     * Sets the designated parameter to SQL <code>NULL</code>.
     *
     * <P><B>Note:</B> You must specify the parameter's SQL type.
     *
     * <p>
     *  将指定的参数设置为SQL <code> NULL </code>。
     * 
     *  <P> <B>注意：</B>您必须指定参数的SQL类型。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param sqlType the SQL type code defined in <code>java.sql.Types</code>
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @exception SQLFeatureNotSupportedException if <code>sqlType</code> is
     * a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
     * <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
     * <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
     *  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
     * or  <code>STRUCT</code> data type and the JDBC driver does not support
     * this data type
     */
    void setNull(int parameterIndex, int sqlType) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>boolean</code> value.
     * The driver converts this
     * to an SQL <code>BIT</code> or <code>BOOLEAN</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code> boolean </code>值。
     * 当驱动程序将其发送到数据库时,将其转换为SQL <code> BIT </code>或<code> BOOLEAN </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement;
     * if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setBoolean(int parameterIndex, boolean x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>byte</code> value.
     * The driver converts this
     * to an SQL <code>TINYINT</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code>字节</code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> TINYINT </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setByte(int parameterIndex, byte x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>short</code> value.
     * The driver converts this
     * to an SQL <code>SMALLINT</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code> short </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> SMALLINT </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setShort(int parameterIndex, short x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>int</code> value.
     * The driver converts this
     * to an SQL <code>INTEGER</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code> int </code>值。当驱动程序将它发送到数据库时,将其转换为SQL <code> INTEGER </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setInt(int parameterIndex, int x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>long</code> value.
     * The driver converts this
     * to an SQL <code>BIGINT</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code> long </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> BIGINT </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setLong(int parameterIndex, long x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>float</code> value.
     * The driver converts this
     * to an SQL <code>REAL</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code> float </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> REAL </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setFloat(int parameterIndex, float x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>double</code> value.
     * The driver converts this
     * to an SQL <code>DOUBLE</code> value when it sends it to the database.
     *
     * <p>
     * 将指定的参数设置为给定的Java <code> double </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> DOUBLE </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setDouble(int parameterIndex, double x) throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.math.BigDecimal</code> value.
     * The driver converts this to an SQL <code>NUMERIC</code> value when
     * it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的<code> java.math.BigDecimal </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> NUMERIC </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java <code>String</code> value.
     * The driver converts this
     * to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
     * (depending on the argument's
     * size relative to the driver's limits on <code>VARCHAR</code> values)
     * when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java <code> String </code>值。
     * 驱动程序在发送时将其转换为SQL <code> VARCHAR </code>或<code> LONGVARCHAR </code>值(取决于参数的大小相对于驱动程序对<code> VARCHAR </code>
     * 值的限制)它到数据库。
     *  将指定的参数设置为给定的Java <code> String </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setString(int parameterIndex, String x) throws SQLException;

    /**
     * Sets the designated parameter to the given Java array of bytes.  The driver converts
     * this to an SQL <code>VARBINARY</code> or <code>LONGVARBINARY</code>
     * (depending on the argument's size relative to the driver's limits on
     * <code>VARBINARY</code> values) when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的Java字节数组。
     * 驱动程序将它发送到SQL <code> VARBINARY </code>或<code> LONGVARBINARY </code>(取决于参数的大小相对于驱动程序对<code> VARBINARY </code>
     * 值的限制)到数据库。
     *  将指定的参数设置为给定的Java字节数组。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setBytes(int parameterIndex, byte x[]) throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Date</code> value
     * using the default time zone of the virtual machine that is running
     * the application.
     * The driver converts this
     * to an SQL <code>DATE</code> value when it sends it to the database.
     *
     * <p>
     *  使用运行应用程序的虚拟机的默认时区将指定的参数设置为给定的<code> java.sql.Date </code>值。
     * 当驱动程序将其发送到数据库时,将其转换为SQL <code> DATE </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setDate(int parameterIndex, java.sql.Date x)
            throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Time</code> value.
     * The driver converts this
     * to an SQL <code>TIME</code> value when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的<code> java.sql.Time </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> TIME </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setTime(int parameterIndex, java.sql.Time x)
            throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Timestamp</code> value.
     * The driver
     * converts this to an SQL <code>TIMESTAMP</code> value when it sends it to the
     * database.
     *
     * <p>
     * 将指定的参数设置为给定的<code> java.sql.Timestamp </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> TIMESTAMP </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>     */
    void setTimestamp(int parameterIndex, java.sql.Timestamp x)
            throws SQLException;

    /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code>. Data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from ASCII to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     *  将指定的参数设置为给定的输入流,其将具有指定的字节数。
     * 当将非常大的ASCII值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.InputStream </code>发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从ASCII到数据库字符格式的任何必要的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the Java input stream that contains the ASCII parameter value
     * @param length the number of bytes in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setAsciiStream(int parameterIndex, java.io.InputStream x, int length)
            throws SQLException;

    /**
     * Sets the designated parameter to the given input stream, which
     * will have the specified number of bytes.
     *
     * When a very large Unicode value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from Unicode to the database char format.
     *
     *The byte format of the Unicode stream must be a Java UTF-8, as defined in the
     *Java Virtual Machine Specification.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     *  将指定的参数设置为给定的输入流,其将具有指定的字节数。
     * 
     *  当非常大的Unicode值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.InputStream </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从Unicode到数据库字符格式的任何必要的转换。
     * 
     *  他的Unicode流的字节格式必须是一个Java UTF-8,在ava虚拟机规范中定义。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x a <code>java.io.InputStream</code> object that contains the
     *        Unicode parameter value
     * @param length the number of bytes in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
     * this method
     * @deprecated Use {@code setCharacterStream}
     */
    @Deprecated
    void setUnicodeStream(int parameterIndex, java.io.InputStream x,
                          int length) throws SQLException;

    /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large binary value is input to a <code>LONGVARBINARY</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     * 将指定的参数设置为给定的输入流,其将具有指定的字节数。
     * 当将非常大的二进制值输入到<code> LONGVARBINARY </code>参数时,通过<code> java.io.InputStream </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the java input stream which contains the binary parameter value
     * @param length the number of bytes in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void setBinaryStream(int parameterIndex, java.io.InputStream x,
                         int length) throws SQLException;

    /**
     * Clears the current parameter values immediately.
     * <P>In general, parameter values remain in force for repeated use of a
     * statement. Setting a parameter value automatically clears its
     * previous value.  However, in some cases it is useful to immediately
     * release the resources used by the current parameter values; this can
     * be done by calling the method <code>clearParameters</code>.
     *
     * <p>
     *  立即清除当前参数值。 <P>通常,参数值对于重复使用语句仍然有效。设置参数值将自动清除其以前的值。
     * 然而,在一些情况下,立即释放由当前参数值使用的资源是有用的;这可以通过调用<code> clearParameters </code>方法来完成。
     * 
     * 
     * @exception SQLException if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     */
    void clearParameters() throws SQLException;

    //----------------------------------------------------------------------
    // Advanced features:

   /**
    * Sets the value of the designated parameter with the given object.
    *
    * This method is similar to {@link #setObject(int parameterIndex,
    * Object x, int targetSqlType, int scaleOrLength)},
    * except that it assumes a scale of zero.
    *
    * <p>
    *  使用给定对象设置指定参数的值。
    * 
    *  这个方法类似于{@link #setObject(int parameterIndex,Object x,int targetSqlType,int scaleOrLength)},除了它假设一个零标
    * 度。
    * 
    * 
    * @param parameterIndex the first parameter is 1, the second is 2, ...
    * @param x the object containing the input parameter value
    * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
    *                      sent to the database
    * @exception SQLException if parameterIndex does not correspond to a parameter
    * marker in the SQL statement; if a database access error occurs or this
    * method is called on a closed PreparedStatement
    * @exception SQLFeatureNotSupportedException if
    * the JDBC driver does not support the specified targetSqlType
    * @see Types
    */
    void setObject(int parameterIndex, Object x, int targetSqlType)
      throws SQLException;

    /**
     * <p>Sets the value of the designated parameter using the given object.
     *
     * <p>The JDBC specification specifies a standard mapping from
     * Java <code>Object</code> types to SQL types.  The given argument
     * will be converted to the corresponding SQL type before being
     * sent to the database.
     *
     * <p>Note that this method may be used to pass datatabase-
     * specific abstract data types, by using a driver-specific Java
     * type.
     *
     * If the object is of a class implementing the interface <code>SQLData</code>,
     * the JDBC driver should call the method <code>SQLData.writeSQL</code>
     * to write it to the SQL data stream.
     * If, on the other hand, the object is of a class implementing
     * <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
     *  <code>Struct</code>, <code>java.net.URL</code>, <code>RowId</code>, <code>SQLXML</code>
     * or <code>Array</code>, the driver should pass it to the database as a
     * value of the corresponding SQL type.
     * <P>
     *<b>Note:</b> Not all databases allow for a non-typed Null to be sent to
     * the backend. For maximum portability, the <code>setNull</code> or the
     * <code>setObject(int parameterIndex, Object x, int sqlType)</code>
     * method should be used
     * instead of <code>setObject(int parameterIndex, Object x)</code>.
     *<p>
     * <b>Note:</b> This method throws an exception if there is an ambiguity, for example, if the
     * object is of a class implementing more than one of the interfaces named above.
     *
     * <p>
     *  <p>使用给定对象设置指定参数的值。
     * 
     *  <p> JDBC规范指定从Java <code> Object </code>类型到SQL类型的标准映射。给定的参数在发送到数据库之前将被转换为相应的SQL类型。
     * 
     *  <p>请注意,此方法可用于通过使用特定于驱动程序的Java类型传递特定于数据库的抽象数据类型。
     * 
     * 如果对象是实现接口<code> SQLData </code>的类,JDBC驱动程序应调用<code> SQLData.writeSQL </code>方法将其写入SQL数据流。
     * 另一方面,如果对象是实现<code> Ref </code>,<code> Blob </code>,<code> Clob </code>,<code> NClob </code> <code> St
     * ruct </code>,<code> java.net.URL </code>,<code> RowId </code>,<code> SQLXML </code>或<code> Array </code>
     * 驱动程序应将其作为相应SQL类型的值传递到数据库。
     * 如果对象是实现接口<code> SQLData </code>的类,JDBC驱动程序应调用<code> SQLData.writeSQL </code>方法将其写入SQL数据流。
     * <P>
     *  b>注意：</b>并非所有数据库都允许将非类型的Null发送到后端。
     * 为了最大的可移植性,应该使用<code> setNull </code>或<code> setObject(int parameterIndex,Object x,int sqlType)</code>
     * 方法,而不是<code> setObject(int parameterIndex,Object x) </code>。
     *  b>注意：</b>并非所有数据库都允许将非类型的Null发送到后端。
     * p>
     *  <b>注意：</b>如果存在歧义,则此方法会引发异常,例如,如果对象是实现上面命名的多个接口的类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs;
     *  this method is called on a closed <code>PreparedStatement</code>
     * or the type of the given object is ambiguous
     */
    void setObject(int parameterIndex, Object x) throws SQLException;

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code> object,
     * which may be any kind of SQL statement.
     * Some prepared statements return multiple results; the <code>execute</code>
     * method handles these complex statements as well as the simpler
     * form of statements handled by the methods <code>executeQuery</code>
     * and <code>executeUpdate</code>.
     * <P>
     * The <code>execute</code> method returns a <code>boolean</code> to
     * indicate the form of the first result.  You must call either the method
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result; you must call <code>getMoreResults</code> to
     * move to any subsequent result(s).
     *
     * <p>
     *  在此<code> PreparedStatement </code>对象中执行SQL语句,该对象可以是任何类型的SQL语句。
     * 一些准备语句返回多个结果; <code> execute </code>方法处理这些复杂语句以及由方法<code> executeQuery </code>和<code> executeUpdate </code>
     * 处理的语句的较简单形式。
     *  在此<code> PreparedStatement </code>对象中执行SQL语句,该对象可以是任何类型的SQL语句。
     * <P>
     * <code> execute </code>方法返回一个<code> boolean </code>以指示第一个结果的格式。
     * 您必须调用<code> getResultSet </code>或<code> getUpdateCount </code>方法检索结果;您必须调用<code> getMoreResults </code>
     * 以移动到任何后续结果。
     * <code> execute </code>方法返回一个<code> boolean </code>以指示第一个结果的格式。
     * 
     * 
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     *         object; <code>false</code> if the first result is an update
     *         count or there is no result
     * @exception SQLException if a database access error occurs;
     * this method is called on a closed <code>PreparedStatement</code>
     * or an argument is supplied to this method
     * @throws SQLTimeoutException when the driver has determined that the
     * timeout value that was specified by the {@code setQueryTimeout}
     * method has been exceeded and has at least attempted to cancel
     * the currently running {@code Statement}
     * @see Statement#execute
     * @see Statement#getResultSet
     * @see Statement#getUpdateCount
     * @see Statement#getMoreResults

     */
    boolean execute() throws SQLException;

    //--------------------------JDBC 2.0-----------------------------

    /**
     * Adds a set of parameters to this <code>PreparedStatement</code>
     * object's batch of commands.
     *
     * <p>
     *  向此<code> PreparedStatement </code>对象的批处理命令中添加一组参数。
     * 
     * 
     * @exception SQLException if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @see Statement#addBatch
     * @since 1.2
     */
    void addBatch() throws SQLException;

    /**
     * Sets the designated parameter to the given <code>Reader</code>
     * object, which is the given number of characters long.
     * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.Reader</code> object. The data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from UNICODE to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     *  将指定的参数设置为给定的<code> Reader </code>对象,这是给定的字符数。
     * 当将非常大的UNICODE值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.Reader </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从UNICODE到数据库char格式的任何必要的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param reader the <code>java.io.Reader</code> object that contains the
     *        Unicode data
     * @param length the number of characters in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.2
     */
    void setCharacterStream(int parameterIndex,
                          java.io.Reader reader,
                          int length) throws SQLException;

    /**
     * Sets the designated parameter to the given
     *  <code>REF(&lt;structured-type&gt;)</code> value.
     * The driver converts this to an SQL <code>REF</code> value when it
     * sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的<code> REF(&lt; structured-type&gt;)</code>值。
     * 当驱动程序将其发送到数据库时,将其转换为SQL <code> REF </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x an SQL <code>REF</code> value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.2
     */
    void setRef (int parameterIndex, Ref x) throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Blob</code> object.
     * The driver converts this to an SQL <code>BLOB</code> value when it
     * sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的<code> java.sql.Blob </code>对象。当驱动程序将其发送到数据库时,将其转换为SQL <code> BLOB </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x a <code>Blob</code> object that maps an SQL <code>BLOB</code> value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.2
     */
    void setBlob (int parameterIndex, Blob x) throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Clob</code> object.
     * The driver converts this to an SQL <code>CLOB</code> value when it
     * sends it to the database.
     *
     * <p>
     * 将指定的参数设置为给定的<code> java.sql.Clob </code>对象。当驱动程序将其发送到数据库时,将其转换为SQL <code> CLOB </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x a <code>Clob</code> object that maps an SQL <code>CLOB</code> value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.2
     */
    void setClob (int parameterIndex, Clob x) throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Array</code> object.
     * The driver converts this to an SQL <code>ARRAY</code> value when it
     * sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的<code> java.sql.Array </code>对象。当驱动程序将其发送到数据库时,将其转换为SQL <code> ARRAY </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.2
     */
    void setArray (int parameterIndex, Array x) throws SQLException;

    /**
     * Retrieves a <code>ResultSetMetaData</code> object that contains
     * information about the columns of the <code>ResultSet</code> object
     * that will be returned when this <code>PreparedStatement</code> object
     * is executed.
     * <P>
     * Because a <code>PreparedStatement</code> object is precompiled, it is
     * possible to know about the <code>ResultSet</code> object that it will
     * return without having to execute it.  Consequently, it is possible
     * to invoke the method <code>getMetaData</code> on a
     * <code>PreparedStatement</code> object rather than waiting to execute
     * it and then invoking the <code>ResultSet.getMetaData</code> method
     * on the <code>ResultSet</code> object that is returned.
     * <P>
     * <B>NOTE:</B> Using this method may be expensive for some drivers due
     * to the lack of underlying DBMS support.
     *
     * <p>
     *  检索包含有关执行此<code> PreparedStatement </code>对象时将返回的<code> ResultSet </code>对象的列的信息的<code> ResultSetMeta
     * Data </code>对象。
     * <P>
     *  因为<code> PreparedStatement </code>对象是预编译的,所以可以知道它将返回的<code> ResultSet </code>对象,而不必执行它。
     * 因此,可以在<code> PreparedStatement </code>对象上调用<code> getMetaData </code>方法,而不是等待执行它,然后调用<code> ResultSet
     * .getMetaData </code>返回的<code> ResultSet </code>对象。
     *  因为<code> PreparedStatement </code>对象是预编译的,所以可以知道它将返回的<code> ResultSet </code>对象,而不必执行它。
     * <P>
     *  <B>注意：</B>对于某些驱动程序,由于缺少底层DBMS支持,使用此方法可能很昂贵。
     * 
     * 
     * @return the description of a <code>ResultSet</code> object's columns or
     *         <code>null</code> if the driver cannot return a
     *         <code>ResultSetMetaData</code> object
     * @exception SQLException if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
     * this method
     * @since 1.2
     */
    ResultSetMetaData getMetaData() throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Date</code> value,
     * using the given <code>Calendar</code> object.  The driver uses
     * the <code>Calendar</code> object to construct an SQL <code>DATE</code> value,
     * which the driver then sends to the database.  With
     * a <code>Calendar</code> object, the driver can calculate the date
     * taking into account a custom timezone.  If no
     * <code>Calendar</code> object is specified, the driver uses the default
     * timezone, which is that of the virtual machine running the application.
     *
     * <p>
     * 使用给定的<code> Calendar </code>对象将指定的参数设置为给定的<code> java.sql.Date </code>值。
     * 驱动程序使用<code> Calendar </code>对象来构造一个SQL <code> DATE </code>值,然后驱动程序发送到数据库。
     * 使用<code> Calendar </code>对象,驱动程序可以计算考虑自定义时区的日期。
     * 如果未指定<code> Calendar </code>对象,则驱动程序将使用默认时区,即运行应用程序的虚拟机的时区。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @param cal the <code>Calendar</code> object the driver will use
     *            to construct the date
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.2
     */
    void setDate(int parameterIndex, java.sql.Date x, Calendar cal)
            throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Time</code> value,
     * using the given <code>Calendar</code> object.  The driver uses
     * the <code>Calendar</code> object to construct an SQL <code>TIME</code> value,
     * which the driver then sends to the database.  With
     * a <code>Calendar</code> object, the driver can calculate the time
     * taking into account a custom timezone.  If no
     * <code>Calendar</code> object is specified, the driver uses the default
     * timezone, which is that of the virtual machine running the application.
     *
     * <p>
     *  使用给定的<code> Calendar </code>对象将指定的参数设置为给定的<code> java.sql.Time </code>值。
     * 驱动程序使用<code> Calendar </code>对象来构造一个SQL <code> TIME </code>值,然后驱动程序发送到数据库。
     * 使用<code> Calendar </code>对象,驱动程序可以计算考虑自定义时区的时间。
     * 如果未指定<code> Calendar </code>对象,则驱动程序将使用默认时区,即运行应用程序的虚拟机的时区。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @param cal the <code>Calendar</code> object the driver will use
     *            to construct the time
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.2
     */
    void setTime(int parameterIndex, java.sql.Time x, Calendar cal)
            throws SQLException;

    /**
     * Sets the designated parameter to the given <code>java.sql.Timestamp</code> value,
     * using the given <code>Calendar</code> object.  The driver uses
     * the <code>Calendar</code> object to construct an SQL <code>TIMESTAMP</code> value,
     * which the driver then sends to the database.  With a
     *  <code>Calendar</code> object, the driver can calculate the timestamp
     * taking into account a custom timezone.  If no
     * <code>Calendar</code> object is specified, the driver uses the default
     * timezone, which is that of the virtual machine running the application.
     *
     * <p>
     * 使用给定的<code> Calendar </code>对象将指定的参数设置为给定的<code> java.sql.Timestamp </code>值。
     * 驱动程序使用<code> Calendar </code>对象来构造一个SQL <code> TIMESTAMP </code>值,驱动程序然后将其发送到数据库。
     * 使用<code> Calendar </code>对象,驱动程序可以计算考虑自定义时区的时间戳。
     * 如果未指定<code> Calendar </code>对象,则驱动程序将使用默认时区,即运行应用程序的虚拟机的时区。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @param cal the <code>Calendar</code> object the driver will use
     *            to construct the timestamp
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.2
     */
    void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal)
            throws SQLException;

    /**
     * Sets the designated parameter to SQL <code>NULL</code>.
     * This version of the method <code>setNull</code> should
     * be used for user-defined types and REF type parameters.  Examples
     * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
     * named array types.
     *
     * <P><B>Note:</B> To be portable, applications must give the
     * SQL type code and the fully-qualified SQL type name when specifying
     * a NULL user-defined or REF parameter.  In the case of a user-defined type
     * the name is the type name of the parameter itself.  For a REF
     * parameter, the name is the type name of the referenced type.  If
     * a JDBC driver does not need the type code or type name information,
     * it may ignore it.
     *
     * Although it is intended for user-defined and Ref parameters,
     * this method may be used to set a null parameter of any JDBC type.
     * If the parameter does not have a user-defined or REF type, the given
     * typeName is ignored.
     *
     *
     * <p>
     *  将指定的参数设置为SQL <code> NULL </code>。此版本的方法<code> setNull </code>应用于用户定义的类型和REF类型参数。
     * 用户定义类型的示例包括：STRUCT,DISTINCT,JAVA_OBJECT和命名的数组类型。
     * 
     *  <P> <B>注意：</B>为了便于移植,当指定NULL用户定义或REF参数时,应用程序必须给出SQL类型代码和完全限定的SQL类型名称。在用户定义类型的情况下,名称是参数本身的类型名称。
     * 对于REF参数,名称是引用类型的类型名称。如果JDBC驱动程序不需要类型代码或类型名称信息,它可能会忽略它。
     * 
     *  虽然它用于用户定义和Ref参数,但此方法可用于设置任何JDBC类型的空参数。如果参数没有用户定义或REF类型,则将忽略给定的typeName。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param sqlType a value from <code>java.sql.Types</code>
     * @param typeName the fully-qualified name of an SQL user-defined type;
     *  ignored if the parameter is not a user-defined type or REF
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @exception SQLFeatureNotSupportedException if <code>sqlType</code> is
     * a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
     * <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
     * <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
     *  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
     * or  <code>STRUCT</code> data type and the JDBC driver does not support
     * this data type or if the JDBC driver does not support this method
     * @since 1.2
     */
  void setNull (int parameterIndex, int sqlType, String typeName)
    throws SQLException;

    //------------------------- JDBC 3.0 -----------------------------------

    /**
     * Sets the designated parameter to the given <code>java.net.URL</code> value.
     * The driver converts this to an SQL <code>DATALINK</code> value
     * when it sends it to the database.
     *
     * <p>
     * 将指定的参数设置为给定的<code> java.net.URL </code>值。当驱动程序将其发送到数据库时,将其转换为SQL <code> DATALINK </code>值。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the <code>java.net.URL</code> object to be set
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.4
     */
    void setURL(int parameterIndex, java.net.URL x) throws SQLException;

    /**
     * Retrieves the number, types and properties of this
     * <code>PreparedStatement</code> object's parameters.
     *
     * <p>
     *  检索此<code> PreparedStatement </code>对象参数的数量,类型和属性。
     * 
     * 
     * @return a <code>ParameterMetaData</code> object that contains information
     *         about the number, types and properties for each
     *  parameter marker of this <code>PreparedStatement</code> object
     * @exception SQLException if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @see ParameterMetaData
     * @since 1.4
     */
    ParameterMetaData getParameterMetaData() throws SQLException;

    //------------------------- JDBC 4.0 -----------------------------------

    /**
     * Sets the designated parameter to the given <code>java.sql.RowId</code> object. The
     * driver converts this to a SQL <code>ROWID</code> value when it sends it
     * to the database
     *
     * <p>
     *  将指定的参数设置为给定的<code> java.sql.RowId </code>对象。当驱动程序将其发送到数据库时,将其转换为SQL <code> ROWID </code>值
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     *
     * @since 1.6
     */
    void setRowId(int parameterIndex, RowId x) throws SQLException;


    /**
     * Sets the designated parameter to the given <code>String</code> object.
     * The driver converts this to a SQL <code>NCHAR</code> or
     * <code>NVARCHAR</code> or <code>LONGNVARCHAR</code> value
     * (depending on the argument's
     * size relative to the driver's limits on <code>NVARCHAR</code> values)
     * when it sends it to the database.
     *
     * <p>
     *  将指定的参数设置为给定的<code> String </code>对象。
     * 驱动程序将其转换为SQL <code> NCHAR </code>或<code> NVARCHAR </code>或<code> LONGNVARCHAR </code>值(取决于参数的大小相对于驱动程
     * 序在<code> </code>值),当它发送到数据库。
     *  将指定的参数设置为给定的<code> String </code>对象。
     * 
     * 
     * @param parameterIndex of the first parameter is 1, the second is 2, ...
     * @param value the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if the driver does not support national
     *         character sets;  if the driver can detect that a data conversion
     *  error could occur; if a database access error occurs; or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
     void setNString(int parameterIndex, String value) throws SQLException;

    /**
     * Sets the designated parameter to a <code>Reader</code> object. The
     * <code>Reader</code> reads the data till end-of-file is reached. The
     * driver does the necessary conversion from Java character format to
     * the national character set in the database.
     * <p>
     *  将指定的参数设置为<code> Reader </code>对象。 <code> Reader </code>读取数据,直到达到文件结束。
     * 驱动程序执行必要的从Java字符格式到数据库中的国家字符集的转换。
     * 
     * 
     * @param parameterIndex of the first parameter is 1, the second is 2, ...
     * @param value the parameter value
     * @param length the number of characters in the parameter data.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if the driver does not support national
     *         character sets;  if the driver can detect that a data conversion
     *  error could occur; if a database access error occurs; or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
     void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException;

    /**
     * Sets the designated parameter to a <code>java.sql.NClob</code> object. The driver converts this to a
     * SQL <code>NCLOB</code> value when it sends it to the database.
     * <p>
     *  将指定的参数设置为<code> java.sql.NClob </code>对象。当驱动程序将其发送到数据库时,将其转换为SQL <code> NCLOB </code>值。
     * 
     * 
     * @param parameterIndex of the first parameter is 1, the second is 2, ...
     * @param value the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if the driver does not support national
     *         character sets;  if the driver can detect that a data conversion
     *  error could occur; if a database access error occurs; or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
     void setNClob(int parameterIndex, NClob value) throws SQLException;

    /**
     * Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number
     * of characters specified by length otherwise a <code>SQLException</code> will be
     * generated when the <code>PreparedStatement</code> is executed.
     *This method differs from the <code>setCharacterStream (int, Reader, int)</code> method
     * because it informs the driver that the parameter value should be sent to
     * the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the
     * driver may have to do extra work to determine whether the parameter
     * data should be sent to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>
     * <p>
     * 将指定的参数设置为<code> Reader </code>对象。
     * 阅读器必须包含长度指定的字符数,否则执行<code> PreparedStatement </code>时会生成<code> SQLException </code>。
     * 他的方法不同于<code> setCharacterStream(int,Reader,int)</code>方法,因为它通知驱动程序应该将参数值作为<code> CLOB </code>发送到服务器。
     * 阅读器必须包含长度指定的字符数,否则执行<code> PreparedStatement </code>时会生成<code> SQLException </code>。
     * 当使用<code> setCharacterStream </code>方法时,驱动程序可能必须做额外的工作来确定参数数据是否应作为<code> LONGVARCHAR </code>或<code> C
     * LOB发送到服务器</code>。
     * 阅读器必须包含长度指定的字符数,否则执行<code> PreparedStatement </code>时会生成<code> SQLException </code>。
     * 
     * 
     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
     * @param reader An object that contains the data to set the parameter value to.
     * @param length the number of characters in the parameter data.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs; this method is called on
     * a closed <code>PreparedStatement</code> or if the length specified is less than zero.
     *
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
     void setClob(int parameterIndex, Reader reader, long length)
       throws SQLException;

    /**
     * Sets the designated parameter to a <code>InputStream</code> object.  The inputstream must contain  the number
     * of characters specified by length otherwise a <code>SQLException</code> will be
     * generated when the <code>PreparedStatement</code> is executed.
     * This method differs from the <code>setBinaryStream (int, InputStream, int)</code>
     * method because it informs the driver that the parameter value should be
     * sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used,
     * the driver may have to do extra work to determine whether the parameter
     * data should be sent to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
     * <p>
     *  将指定的参数设置为<code> InputStream </code>对象。
     * 输入流必须包含由长度指定的字符数,否则执行<code> PreparedStatement </code>时将生成<code> SQLException </code>。
     * 此方法与<code> setBinaryStream(int,InputStream,int)</code>方法不同,因为它通知驱动程序应将参数值作为<code> BLOB </code>发送到服务器。
     * 输入流必须包含由长度指定的字符数,否则执行<code> PreparedStatement </code>时将生成<code> SQLException </code>。
     * 当使用<code> setBinaryStream </code>方法时,驱动程序可能必须做额外的工作来确定参数数据是否应作为<code> LONGVARBINARY </code>或<code> BL
     * OB </code>。
     * 输入流必须包含由长度指定的字符数,否则执行<code> PreparedStatement </code>时将生成<code> SQLException </code>。
     * 
     * 
     * @param parameterIndex index of the first parameter is 1,
     * the second is 2, ...
     * @param inputStream An object that contains the data to set the parameter
     * value to.
     * @param length the number of bytes in the parameter data.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs;
     * this method is called on a closed <code>PreparedStatement</code>;
     *  if the length specified
     * is less than zero or if the number of bytes in the inputstream does not match
     * the specified length.
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     *
     * @since 1.6
     */
     void setBlob(int parameterIndex, InputStream inputStream, long length)
        throws SQLException;
    /**
     * Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number
     * of characters specified by length otherwise a <code>SQLException</code> will be
     * generated when the <code>PreparedStatement</code> is executed.
     * This method differs from the <code>setCharacterStream (int, Reader, int)</code> method
     * because it informs the driver that the parameter value should be sent to
     * the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the
     * driver may have to do extra work to determine whether the parameter
     * data should be sent to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code>
     * <p>
     * 将指定的参数设置为<code> Reader </code>对象。
     * 阅读器必须包含长度指定的字符数,否则执行<code> PreparedStatement </code>时会生成<code> SQLException </code>。
     * 此方法与<code> setCharacterStream(int,Reader,int)</code>方法不同,因为它通知驱动程序应将参数值作为<code> NCLOB </code>发送到服务器。
     * 当使用<code> setCharacterStream </code>方法时,驱动程序可能必须做额外的工作来确定参数数据是否应作为<code> LONGNVARCHAR </code>或<code> 
     * NCLOB发送到服务器</code>。
     * 此方法与<code> setCharacterStream(int,Reader,int)</code>方法不同,因为它通知驱动程序应将参数值作为<code> NCLOB </code>发送到服务器。
     * 
     * 
     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
     * @param reader An object that contains the data to set the parameter value to.
     * @param length the number of characters in the parameter data.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if the length specified is less than zero;
     * if the driver does not support national character sets;
     * if the driver can detect that a data conversion
     *  error could occur;  if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     *
     * @since 1.6
     */
     void setNClob(int parameterIndex, Reader reader, long length)
       throws SQLException;

     /**
      * Sets the designated parameter to the given <code>java.sql.SQLXML</code> object.
      * The driver converts this to an
      * SQL <code>XML</code> value when it sends it to the database.
      * <p>
      *
      * <p>
      *  将指定的参数设置为给定的<code> java.sql.SQLXML </code>对象。当驱动程序将其发送到数据库时,将其转换为SQL <code> XML </code>值。
      * <p>
      * 
      * 
      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
      * @param xmlObject a <code>SQLXML</code> object that maps an SQL <code>XML</code> value
      * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs;
      *  this method is called on a closed <code>PreparedStatement</code>
      * or the <code>java.xml.transform.Result</code>,
      *  <code>Writer</code> or <code>OutputStream</code> has not been closed for
      * the <code>SQLXML</code> object
      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
      *
      * @since 1.6
      */
     void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException;

    /**
     * <p>Sets the value of the designated parameter with the given object.
     *
     * If the second argument is an <code>InputStream</code> then the stream must contain
     * the number of bytes specified by scaleOrLength.  If the second argument is a
     * <code>Reader</code> then the reader must contain the number of characters specified
     * by scaleOrLength. If these conditions are not true the driver will generate a
     * <code>SQLException</code> when the prepared statement is executed.
     *
     * <p>The given Java object will be converted to the given targetSqlType
     * before being sent to the database.
     *
     * If the object has a custom mapping (is of a class implementing the
     * interface <code>SQLData</code>),
     * the JDBC driver should call the method <code>SQLData.writeSQL</code> to
     * write it to the SQL data stream.
     * If, on the other hand, the object is of a class implementing
     * <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
     *  <code>Struct</code>, <code>java.net.URL</code>,
     * or <code>Array</code>, the driver should pass it to the database as a
     * value of the corresponding SQL type.
     *
     * <p>Note that this method may be used to pass database-specific
     * abstract data types.
     *
     * <p>
     *  <p>使用给定对象设置指定参数的值。
     * 
     *  如果第二个参数是<code> InputStream </code>,那么流必须包含由scaleOrLength指定的字节数。
     * 如果第二个参数是<code> Reader </code>,则读者必须包含由scaleOrLength指定的字符数。
     * 如果这些条件不成立,驱动程序将在执行准备语句时生成<code> SQLException </code>。
     * 
     *  <p>给定的Java对象在发送到数据库之前将被转换为给定的targetSqlType。
     * 
     * 如果对象具有自定义映射(是实现接口<code> SQLData </code>的类),JDBC驱动程序应调用<code> SQLData.writeSQL </code>方法将其写入SQL数据流。
     * 另一方面,如果对象是实现<code> Ref </code>,<code> Blob </code>,<code> Clob </code>,<code> NClob </code> <code> St
     * ruct </code>,<code> java.net.URL </code>或<code> Array </code>,驱动程序应将其作为相应SQL类型的值传递到数据库。
     * 如果对象具有自定义映射(是实现接口<code> SQLData </code>的类),JDBC驱动程序应调用<code> SQLData.writeSQL </code>方法将其写入SQL数据流。
     * 
     *  <p>请注意,此方法可用于传递特定于数据库的抽象数据类型。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
     * sent to the database. The scale argument may further qualify this type.
     * @param scaleOrLength for <code>java.sql.Types.DECIMAL</code>
     *          or <code>java.sql.Types.NUMERIC types</code>,
     *          this is the number of digits after the decimal point. For
     *          Java Object types <code>InputStream</code> and <code>Reader</code>,
     *          this is the length
     *          of the data in the stream or reader.  For all other types,
     *          this value will be ignored.
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs;
     * this method is called on a closed <code>PreparedStatement</code> or
     *            if the Java Object specified by x is an InputStream
     *            or Reader object and the value of the scale parameter is less
     *            than zero
     * @exception SQLFeatureNotSupportedException if
     * the JDBC driver does not support the specified targetSqlType
     * @see Types
     *
     */
    void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)
            throws SQLException;
   /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code>. Data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from ASCII to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     *  将指定的参数设置为给定的输入流,其将具有指定的字节数。
     * 当将非常大的ASCII值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.InputStream </code>发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从ASCII到数据库字符格式的任何必要的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the Java input stream that contains the ASCII parameter value
     * @param length the number of bytes in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.6
    */
    void setAsciiStream(int parameterIndex, java.io.InputStream x, long length)
            throws SQLException;
    /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large binary value is input to a <code>LONGVARBINARY</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     *  将指定的参数设置为给定的输入流,其将具有指定的字节数。
     * 当将非常大的二进制值输入到<code> LONGVARBINARY </code>参数时,通过<code> java.io.InputStream </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。
     * 
     * <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the java input stream which contains the binary parameter value
     * @param length the number of bytes in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.6
     */
    void setBinaryStream(int parameterIndex, java.io.InputStream x,
                         long length) throws SQLException;
        /**
     * Sets the designated parameter to the given <code>Reader</code>
     * object, which is the given number of characters long.
     * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.Reader</code> object. The data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from UNICODE to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * <p>
     *  将指定的参数设置为给定的<code> Reader </code>对象,这是给定的字符数。
     * 当将非常大的UNICODE值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.Reader </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从UNICODE到数据库char格式的任何必要的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param reader the <code>java.io.Reader</code> object that contains the
     *        Unicode data
     * @param length the number of characters in the stream
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @since 1.6
     */
    void setCharacterStream(int parameterIndex,
                          java.io.Reader reader,
                          long length) throws SQLException;
    //-----
    /**
     * Sets the designated parameter to the given input stream.
     * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code>. Data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from ASCII to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setAsciiStream</code> which takes a length parameter.
     *
     * <p>
     *  将指定的参数设置为给定的输入流。
     * 当将非常大的ASCII值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.InputStream </code>发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从ASCII到数据库字符格式的任何必要的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     *  <P> <B>注意：</B>请查看您的JDBC驱动程序文档,以确定是否可以使用一个使用length参数的<code> setAsciiStream </code>版本更高效。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the Java input stream that contains the ASCII parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
       * @since 1.6
    */
    void setAsciiStream(int parameterIndex, java.io.InputStream x)
            throws SQLException;
    /**
     * Sets the designated parameter to the given input stream.
     * When a very large binary value is input to a <code>LONGVARBINARY</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setBinaryStream</code> which takes a length parameter.
     *
     * <p>
     * 将指定的参数设置为给定的输入流。
     * 当将非常大的二进制值输入到<code> LONGVARBINARY </code>参数时,通过<code> java.io.InputStream </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     *  <P> <B>注意：</B>请查看您的JDBC驱动程序文档,以确定是否可以使用一个使用length参数的<code> setBinaryStream </code>版本更高效。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the java input stream which contains the binary parameter value
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
    void setBinaryStream(int parameterIndex, java.io.InputStream x)
    throws SQLException;
        /**
     * Sets the designated parameter to the given <code>Reader</code>
     * object.
     * When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
     * parameter, it may be more practical to send it via a
     * <code>java.io.Reader</code> object. The data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will
     * do any necessary conversion from UNICODE to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setCharacterStream</code> which takes a length parameter.
     *
     * <p>
     *  将指定的参数设置为给定的<code> Reader </code>对象。
     * 当将非常大的UNICODE值输入到<code> LONGVARCHAR </code>参数时,通过<code> java.io.Reader </code>对象发送它可能更实用。
     * 将根据需要从流中读取数据,直到达到文件结束。 JDBC驱动程序将执行从UNICODE到数据库char格式的任何必要的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     *  <P> <B>注意：</B>请查看您的JDBC驱动程序文档,以确定是否可以使用一个带有长度参数的<code> setCharacterStream </code>版本更高效。
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param reader the <code>java.io.Reader</code> object that contains the
     *        Unicode data
     * @exception SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
    void setCharacterStream(int parameterIndex,
                          java.io.Reader reader) throws SQLException;
  /**
     * Sets the designated parameter to a <code>Reader</code> object. The
     * <code>Reader</code> reads the data till end-of-file is reached. The
     * driver does the necessary conversion from Java character format to
     * the national character set in the database.

     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setNCharacterStream</code> which takes a length parameter.
     *
     * <p>
     * 将指定的参数设置为<code> Reader </code>对象。 <code> Reader </code>读取数据,直到达到文件结束。
     * 驱动程序执行必要的从Java字符格式到数据库中的国家字符集的转换。
     * 
     *  <P> <B>注意：</B>此流对象可以是标准Java流对象或实现标准接口的自己的子类。
     *  <P> <B>注意：</B>请参阅您的JDBC驱动程序文档,以确定是否可以使用一个使用length参数的<code> setNCharacterStream </code>版本更高效。
     * 
     * 
     * @param parameterIndex of the first parameter is 1, the second is 2, ...
     * @param value the parameter value
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if the driver does not support national
     *         character sets;  if the driver can detect that a data conversion
     *  error could occur; if a database access error occurs; or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
     void setNCharacterStream(int parameterIndex, Reader value) throws SQLException;

    /**
     * Sets the designated parameter to a <code>Reader</code> object.
     * This method differs from the <code>setCharacterStream (int, Reader)</code> method
     * because it informs the driver that the parameter value should be sent to
     * the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the
     * driver may have to do extra work to determine whether the parameter
     * data should be sent to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>
     *
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setClob</code> which takes a length parameter.
     *
     * <p>
     *  将指定的参数设置为<code> Reader </code>对象。
     * 此方法与<code> setCharacterStream(int,Reader)</code>方法不同,因为它通知驱动程序应将参数值作为<code> CLOB </code>发送到服务器。
     * 当使用<code> setCharacterStream </code>方法时,驱动程序可能必须做额外的工作来确定参数数据是否应作为<code> LONGVARCHAR </code>或<code> C
     * LOB发送到服务器</code>。
     * 此方法与<code> setCharacterStream(int,Reader)</code>方法不同,因为它通知驱动程序应将参数值作为<code> CLOB </code>发送到服务器。
     * 
     *  <P> <B>注意：</B>请查看您的JDBC驱动程序文档,以确定是否可以使用一个使用length参数的<code> setClob </code>版本更高效。
     * 
     * 
     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
     * @param reader An object that contains the data to set the parameter value to.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs; this method is called on
     * a closed <code>PreparedStatement</code>or if parameterIndex does not correspond to a parameter
     * marker in the SQL statement
     *
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     * @since 1.6
     */
     void setClob(int parameterIndex, Reader reader)
       throws SQLException;

    /**
     * Sets the designated parameter to a <code>InputStream</code> object.
     * This method differs from the <code>setBinaryStream (int, InputStream)</code>
     * method because it informs the driver that the parameter value should be
     * sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used,
     * the driver may have to do extra work to determine whether the parameter
     * data should be sent to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
     *
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setBlob</code> which takes a length parameter.
     *
     * <p>
     * 将指定的参数设置为<code> InputStream </code>对象。
     * 此方法与<code> setBinaryStream(int,InputStream)</code>方法不同,因为它通知驱动程序应将参数值作为<code> BLOB </code>发送到服务器。
     * 当使用<code> setBinaryStream </code>方法时,驱动程序可能必须做额外的工作来确定参数数据是否应作为<code> LONGVARBINARY </code>或<code> BL
     * OB </code>。
     * 此方法与<code> setBinaryStream(int,InputStream)</code>方法不同,因为它通知驱动程序应将参数值作为<code> BLOB </code>发送到服务器。
     * 
     *  <P> <B>注意：</B>请查看您的JDBC驱动程序文档,以确定是否使用一个带有长度参数的<code> setBlob </code>版本更高效。
     * 
     * 
     * @param parameterIndex index of the first parameter is 1,
     * the second is 2, ...
     * @param inputStream An object that contains the data to set the parameter
     * value to.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement; if a database access error occurs;
     * this method is called on a closed <code>PreparedStatement</code> or
     * if parameterIndex does not correspond
     * to a parameter marker in the SQL statement,
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     *
     * @since 1.6
     */
     void setBlob(int parameterIndex, InputStream inputStream)
        throws SQLException;
    /**
     * Sets the designated parameter to a <code>Reader</code> object.
     * This method differs from the <code>setCharacterStream (int, Reader)</code> method
     * because it informs the driver that the parameter value should be sent to
     * the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the
     * driver may have to do extra work to determine whether the parameter
     * data should be sent to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code>
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setNClob</code> which takes a length parameter.
     *
     * <p>
     *  将指定的参数设置为<code> Reader </code>对象。
     * 此方法与<code> setCharacterStream(int,Reader)</code>方法不同,因为它通知驱动程序应将参数值作为<code> NCLOB </code>发送到服务器。
     * 当使用<code> setCharacterStream </code>方法时,驱动程序可能必须做额外的工作来确定参数数据是否应作为<code> LONGNVARCHAR </code>或<code> 
     * NCLOB发送到服务器</code> <P> <B>注意：</B>请参考您的JDBC驱动程序文档,以确定是否使用一个带有长度参数的<code> setNClob </code>版本更高效。
     * 此方法与<code> setCharacterStream(int,Reader)</code>方法不同,因为它通知驱动程序应将参数值作为<code> NCLOB </code>发送到服务器。
     * 
     * 
     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
     * @param reader An object that contains the data to set the parameter value to.
     * @throws SQLException if parameterIndex does not correspond to a parameter
     * marker in the SQL statement;
     * if the driver does not support national character sets;
     * if the driver can detect that a data conversion
     *  error could occur;  if a database access error occurs or
     * this method is called on a closed <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
     *
     * @since 1.6
     */
     void setNClob(int parameterIndex, Reader reader)
       throws SQLException;

    //------------------------- JDBC 4.2 -----------------------------------

    /**
     * <p>Sets the value of the designated parameter with the given object.
     *
     * If the second argument is an {@code InputStream} then the stream
     * must contain the number of bytes specified by scaleOrLength.
     * If the second argument is a {@code Reader} then the reader must
     * contain the number of characters specified by scaleOrLength. If these
     * conditions are not true the driver will generate a
     * {@code SQLException} when the prepared statement is executed.
     *
     * <p>The given Java object will be converted to the given targetSqlType
     * before being sent to the database.
     *
     * If the object has a custom mapping (is of a class implementing the
     * interface {@code SQLData}),
     * the JDBC driver should call the method {@code SQLData.writeSQL} to
     * write it to the SQL data stream.
     * If, on the other hand, the object is of a class implementing
     * {@code Ref}, {@code Blob}, {@code Clob},  {@code NClob},
     *  {@code Struct}, {@code java.net.URL},
     * or {@code Array}, the driver should pass it to the database as a
     * value of the corresponding SQL type.
     *
     * <p>Note that this method may be used to pass database-specific
     * abstract data types.
     *<P>
     * The default implementation will throw {@code SQLFeatureNotSupportedException}
     *
     * <p>
     *  <p>使用给定对象设置指定参数的值。
     * 
     * 如果第二个参数是{@code InputStream},那么流必须包含由scaleOrLength指定的字节数。
     * 如果第二个参数是{@code Reader},则读者必须包含由scaleOrLength指定的字符数。如果这些条件不为真,驱动程序将在执行准备语句时生成{@code SQLException}。
     * 
     *  <p>给定的Java对象在发送到数据库之前将被转换为给定的targetSqlType。
     * 
     *  如果对象具有自定义映射(是实现接口{@code SQLData}的类),JDBC驱动程序应调用{@code SQLData.writeSQL}方法将其写入SQL数据流。
     * 另一方面,如果对象是实现{@code Ref},{@code Blob},{@code Clob},{@code NClob},{@code Struct},{@code java.net .URL}或
     * {@code Array},驱动程序应将其作为相应SQL类型的值传递到数据库。
     *  如果对象具有自定义映射(是实现接口{@code SQLData}的类),JDBC驱动程序应调用{@code SQLData.writeSQL}方法将其写入SQL数据流。
     * 
     *  <p>请注意,此方法可用于传递特定于数据库的抽象数据类型。
     * P>
     *  默认实现将抛出{@code SQLFeatureNotSupportedException}
     * 
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @param targetSqlType the SQL type to be sent to the database. The
     * scale argument may further qualify this type.
     * @param scaleOrLength for {@code java.sql.JDBCType.DECIMAL}
     *          or {@code java.sql.JDBCType.NUMERIC types},
     *          this is the number of digits after the decimal point. For
     *          Java Object types {@code InputStream} and {@code Reader},
     *          this is the length
     *          of the data in the stream or reader.  For all other types,
     *          this value will be ignored.
     * @exception SQLException if parameterIndex does not correspond to a
     * parameter marker in the SQL statement; if a database access error occurs
     * or this method is called on a closed {@code PreparedStatement}  or
     *            if the Java Object specified by x is an InputStream
     *            or Reader object and the value of the scale parameter is less
     *            than zero
     * @exception SQLFeatureNotSupportedException if
     * the JDBC driver does not support the specified targetSqlType
     * @see JDBCType
     * @see SQLType
     * @since 1.8
     */
    default void setObject(int parameterIndex, Object x, SQLType targetSqlType,
             int scaleOrLength) throws SQLException {
        throw new SQLFeatureNotSupportedException("setObject not implemented");
    }

    /**
     * Sets the value of the designated parameter with the given object.
     *
     * This method is similar to {@link #setObject(int parameterIndex,
     * Object x, SQLType targetSqlType, int scaleOrLength)},
     * except that it assumes a scale of zero.
     *<P>
     * The default implementation will throw {@code SQLFeatureNotSupportedException}
     *
     * <p>
     * 
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @param targetSqlType the SQL type to be sent to the database
     * @exception SQLException if parameterIndex does not correspond to a
     * parameter marker in the SQL statement; if a database access error occurs
     * or this method is called on a closed {@code PreparedStatement}
     * @exception SQLFeatureNotSupportedException if
     * the JDBC driver does not support the specified targetSqlType
     * @see JDBCType
     * @see SQLType
     * @since 1.8
     */
    default void setObject(int parameterIndex, Object x, SQLType targetSqlType)
      throws SQLException {
        throw new SQLFeatureNotSupportedException("setObject not implemented");
    }

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code> object,
     * which must be an SQL Data Manipulation Language (DML) statement,
     * such as <code>INSERT</code>, <code>UPDATE</code> or
     * <code>DELETE</code>; or an SQL statement that returns nothing,
     * such as a DDL statement.
     * <p>
     * This method should be used when the returned row count may exceed
     * {@link Integer#MAX_VALUE}.
     * <p>
     * The default implementation will throw {@code UnsupportedOperationException}
     *
     * <p>
     *  使用给定对象设置指定参数的值。
     * 
     *  此方法类似于{@link #setObject(int parameterIndex,Object x,SQLType targetSqlType,int scaleOrLength)},除了它假定为
     * 零的比例。
     * P>
     *  默认实现将抛出{@code SQLFeatureNotSupportedException}
     * 
     * 
     * @return either (1) the row count for SQL Data Manipulation Language
     * (DML) statements or (2) 0 for SQL statements that return nothing
     * @exception SQLException if a database access error occurs;
     * this method is called on a closed  <code>PreparedStatement</code>
     * or the SQL statement returns a <code>ResultSet</code> object
     * @throws SQLTimeoutException when the driver has determined that the
     * timeout value that was specified by the {@code setQueryTimeout}
     * method has been exceeded and has at least attempted to cancel
     * the currently running {@code Statement}
     * @since 1.8
     */
    default long executeLargeUpdate() throws SQLException {
        throw new UnsupportedOperationException("executeLargeUpdate not implemented");
    }
}
