/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/*
 * Copyright 2001-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * <p>
 *  版权所有2001-2004 Apache软件基金会。
 * 
 *  根据Apache许可证2.0版("许可证")授权;您不能使用此文件,除非符合许可证。您可以通过获取许可证的副本
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  除非适用法律要求或书面同意,否则根据许可证分发的软件按"原样"分发,不附带任何明示或暗示的担保或条件。请参阅管理许可证下的权限和限制的特定语言的许可证。
 * 
 */
/*
 * $Id: AttributeSet.java,v 1.5 2005/09/28 13:48:04 pvedula Exp $
 * <p>
 *  $ Id：AttributeSet.java,v 1.5 2005/09/28 13:48:04 pvedula Exp $
 * 
 */

package com.sun.org.apache.xalan.internal.xsltc.compiler;

import java.util.Enumeration;
import java.util.Vector;

import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
import com.sun.org.apache.bcel.internal.generic.INVOKESPECIAL;
import com.sun.org.apache.bcel.internal.generic.InstructionList;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.AttributeSetMethodGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
import com.sun.org.apache.xml.internal.utils.XML11Char;

/**
/* <p>
/* 
 * @author Jacek Ambroziak
 * @author Santiago Pericas-Geertsen
 * @author Morten Jorgensen
 */
final class AttributeSet extends TopLevelElement {

    // This prefix is used for the method name of attribute set methods
    private static final String AttributeSetPrefix = "$as$";

    // Element contents
    private QName            _name;
    private UseAttributeSets _useSets;
    private AttributeSet     _mergeSet;
    private String           _method;
    private boolean          _ignore = false;

    /**
     * Returns the QName of this attribute set
     * <p>
     *  返回此属性集的QName
     * 
     */
    public QName getName() {
        return _name;
    }

    /**
     * Returns the method name of this attribute set. This method name is
     * generated by the compiler (XSLTC)
     * <p>
     *  返回此属性集的方法名称。这个方法名由编译器(XSLTC)生成,
     * 
     */
    public String getMethodName() {
        return _method;
    }

    /**
     * Call this method to prevent a method for being compiled for this set.
     * This is used in case several <xsl:attribute-set...> elements constitute
     * a single set (with one name). The last element will merge itself with
     * any previous set(s) with the same name and disable the other set(s).
     * <p>
     *  调用此方法以防止为此集合编译方法。这在几个<xsl：attribute-set ...>元素构成单个集合(使用一个名称)的情况下使用。
     * 最后一个元素将与具有相同名称的任何先前的集合自身合并,并禁用其他集合。
     * 
     */
    public void ignore() {
        _ignore = true;
    }

    /**
     * Parse the contents of this attribute set. Recognised attributes are
     * "name" (required) and "use-attribute-sets" (optional).
     * <p>
     *  解析此属性集的内容。可识别的属性是"name"(必需)和"use-attribute-sets"(可选)。
     * 
     */
    public void parseContents(Parser parser) {

        // Get this attribute set's name
        final String name = getAttribute("name");

        if (!XML11Char.isXML11ValidQName(name)) {
            ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_QNAME_ERR, name, this);
            parser.reportError(Constants.ERROR, err);
        }
        _name = parser.getQNameIgnoreDefaultNs(name);
        if ((_name == null) || (_name.equals(EMPTYSTRING))) {
            ErrorMsg msg = new ErrorMsg(ErrorMsg.UNNAMED_ATTRIBSET_ERR, this);
            parser.reportError(Constants.ERROR, msg);
        }

        // Get any included attribute sets (similar to inheritance...)
        final String useSets = getAttribute("use-attribute-sets");
        if (useSets.length() > 0) {
            if (!Util.isValidQNames(useSets)) {
                ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_QNAME_ERR, useSets, this);
                parser.reportError(Constants.ERROR, err);
            }
            _useSets = new UseAttributeSets(useSets, parser);
        }

        // Parse the contents of this node. All child elements must be
        // <xsl:attribute> elements. Other elements cause an error.
        final Vector contents = getContents();
        final int count = contents.size();
        for (int i=0; i<count; i++) {
            SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
            if (child instanceof XslAttribute) {
                parser.getSymbolTable().setCurrentNode(child);
                child.parseContents(parser);
            }
            else if (child instanceof Text) {
                // ignore
            }
            else {
                ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_CHILD_ERR, this);
                parser.reportError(Constants.ERROR, msg);
            }
        }

        // Point the symbol table back at us...
        parser.getSymbolTable().setCurrentNode(this);
    }

    /**
     * Type check the contents of this element
     * <p>
     *  类型检查此元素的内容
     * 
     */
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

        if (_ignore) return (Type.Void);

        // _mergeSet Point to any previous definition of this attribute set
        _mergeSet = stable.addAttributeSet(this);

        _method = AttributeSetPrefix + getXSLTC().nextAttributeSetSerial();

        if (_useSets != null) _useSets.typeCheck(stable);
        typeCheckContents(stable);
        return Type.Void;
    }

    /**
     * Compile a method that outputs the attributes in this set
     * <p>
     *  编译输出此集合中的属性的方法
     */
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

        if (_ignore) return;

        // Create a new method generator for an attribute set method
        methodGen = new AttributeSetMethodGenerator(_method, classGen);

        // Generate a reference to previous attribute-set definitions with the
        // same name first.  Those later in the stylesheet take precedence.
        if (_mergeSet != null) {
            final ConstantPoolGen cpg = classGen.getConstantPool();
            final InstructionList il = methodGen.getInstructionList();
            final String methodName = _mergeSet.getMethodName();

            il.append(classGen.loadTranslet());
            il.append(methodGen.loadDOM());
            il.append(methodGen.loadIterator());
            il.append(methodGen.loadHandler());
            il.append(methodGen.loadCurrentNode());
            final int method = cpg.addMethodref(classGen.getClassName(),
                                                methodName, ATTR_SET_SIG);
            il.append(new INVOKESPECIAL(method));
        }

        // Translate other used attribute sets first, as local attributes
        // take precedence (last attributes overrides first)
        if (_useSets != null) _useSets.translate(classGen, methodGen);

        // Translate all local attributes
        final Enumeration attributes = elements();
        while (attributes.hasMoreElements()) {
            SyntaxTreeNode element = (SyntaxTreeNode)attributes.nextElement();
            if (element instanceof XslAttribute) {
                final XslAttribute attribute = (XslAttribute)element;
                attribute.translate(classGen, methodGen);
            }
        }
        final InstructionList il = methodGen.getInstructionList();
        il.append(RETURN);

        classGen.addMethod(methodGen);
    }

    public String toString() {
        StringBuffer buf = new StringBuffer("attribute-set: ");
        // Translate all local attributes
        final Enumeration attributes = elements();
        while (attributes.hasMoreElements()) {
            final XslAttribute attribute =
                (XslAttribute)attributes.nextElement();
            buf.append(attribute);
        }
        return(buf.toString());
    }
}
