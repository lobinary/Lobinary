/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/*
 * Copyright 2001-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * <p>
 *  版权所有2001-2004 Apache软件基金会。
 * 
 *  根据Apache许可证2.0版("许可证")授权;您不能使用此文件,除非符合许可证。您可以通过获取许可证的副本
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  除非适用法律要求或书面同意,否则根据许可证分发的软件按"原样"分发,不附带任何明示或暗示的担保或条件。请参阅管理许可证下的权限和限制的特定语言的许可证。
 * 
 */

/*
 * $Id: MethodGenerator.java,v 1.10 2010-11-01 04:34:19 joehw Exp $
 * <p>
 *  $ Id：MethodGenerator.java,v 1.10 2010-11-01 04:34:19 joehw Exp $
 * 
 */
package com.sun.org.apache.xalan.internal.xsltc.compiler.util;
import java.io.DataOutputStream;
import java.io.IOException;

import com.sun.org.apache.bcel.internal.Constants;
import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
import com.sun.org.apache.bcel.internal.generic.Instruction;
import com.sun.org.apache.bcel.internal.generic.Visitor;

/**
 * A special abstract dummy subclass of
 * {@link org.apache.bcel.generic.Instruction} used to mark locations of
 * interest in an {@link com.sun.org.apache.bcel.internal.generic.InstructionList}.  It and
 * its subclasses are only used as placeholders, and do not contribute to the
 * actual byte code instruction stream.
 * <p>
 *  {@link org.apache.bcel.generic.Instruction}的特殊抽象虚拟子类用于在{@link com.sun.org.apache.bcel.internal.generic.InstructionList}
 * 中标记感兴趣的位置。
 * 它及其子类只用作占位符,并且不对实际的字节码指令流有贡献。
 * 
 */
abstract class MarkerInstruction extends Instruction {
    /**
     * Zero-argument constructor.  Sets the opcode to an invalid value and
     * sets the length to zero, as it will not be written as part of the
     * generated byte code.
     * <p>
     *  零参数构造函数。将操作码设置为无效值,并将长度设置为零,因为它不会作为生成的字节码的一部分写入。
     * 
     */
    public MarkerInstruction() {
        super(Constants.UNDEFINED, (short) 0);
    }

    /**
     * {@link com.sun.org.apache.bcel.internal.generic.Visitor}s will know nothing about this
     * kind of {@link org.apche.bcel.generic.Instruction}, so this method does
     * nothing.
     * <p>
     *  {@link com.sun.org.apache.bcel.internal.generic.Visitor}将不会知道这种{@link org.apche.bcel.generic.Instruction}
     * ,所以这个方法什么也不做。
     * 
     */
    public void accept(Visitor v) {
    }

    /**
     * The number of JVM stack entries consumed by the instruction.
     * This instruction is just a place holder, so it does not consume any
     * stack entries.
     * <p>
     * 指令占用的JVM堆栈条目数。这个指令只是一个占位符,所以它不消耗任何堆栈条目。
     * 
     * 
     * @param cpg The {@link com.sun.org.apache.bcel.internal.generic.ConstantPoolGen} for the
     * current {@link com.sun.org.apache.bcel.internal.generic.ClassGen}
     * @return <code>0</code> always
     */
    final public int consumeStack(ConstantPoolGen cpg) {
        return 0;
    }
    /**
     * The number of JVM stack entries produced by the instruction.
     * This instruction is just a place holder, so it does not produce any
     * stack entries.
     * <p>
     *  指令产生的JVM堆栈条目数。这个指令只是一个占位符,所以它不产生任何堆栈条目。
     * 
     * 
     * @param cpg The {@link com.sun.org.apache.bcel.internal.generic.ConstantPoolGen} for the
     * current {@link com.sun.org.apache.bcel.internal.generic.ClassGen}
     * @return <code>0</code> always
     */
    final public int produceStack(ConstantPoolGen cpg) {
        return 0;
    }

    /**
     * Produce a copy of the instruction.  By default a
     * {@link MarkerInstruction} has no parameters, so the base implementation
     * of {@link #copy()} returns the instruction itself.
     * <p>
     *  生成指令的副本。默认情况下,{@link MarkerInstruction}没有参数,因此{@link #copy()}的基本实现返回指令本身。
     * 
     * 
     * @return The instruction itself.
     */
    public Instruction copy() {
        return this;
    }
    /**
     * Dump instruction as byte code to stream out.  A {@link MarkerInstruction}
     * has no effect on the generated byte code so it is never emitted to the
     * output stream.
     * <p>
     *  转储指令作为字节码流输出。 {@link MarkerInstruction}对生成的字节代码没有影响,因此它不会被发送到输出流。
     * 
     * @param out Output stream
     */
    final public void dump(DataOutputStream out) throws IOException {
    }
}
