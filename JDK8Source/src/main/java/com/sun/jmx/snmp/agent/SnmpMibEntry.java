/***** Lobxxx Translate Finished ******/
/*
 * Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package com.sun.jmx.snmp.agent;

// java imports
//
import com.sun.jmx.snmp.SnmpDefinitions;
import java.io.Serializable;
import com.sun.jmx.snmp.SnmpStatusException;

/**
 * Represents a node in an SNMP MIB which corresponds to a table entry
 * meta node.
 * <P>
 * This class is used by the class generated by <CODE>mibgen</CODE>.
 * You should not need to use this class directly.
 *
 * <p><b>This API is a Sun Microsystems internal API  and is subject
 * to change without notice.</b></p>
 * <p>
 *  表示对应于表条目元节点的SNMP MIB中的节点。
 * <P>
 *  此类由<CODE> mibgen </CODE>生成的类使用。你不应该直接使用这个类。
 * 
 *  <p> <b>此API是Sun Microsystems的内部API,如有更改,恕不另行通知。</b> </p>
 * 
 */

public abstract class SnmpMibEntry extends SnmpMibNode
    implements Serializable {

    /**
     * Tells whether the given arc identifies a variable (scalar object) in
     * this entry.
     *
     * <p>
     *  指示给定的圆弧是否在此条目中标识变量(标量对象)。
     * 
     * 
     * @param arc An OID arc.
     *
     * @return <CODE>true</CODE> if `arc' leads to a variable.
     */
    public abstract boolean isVariable(long arc);

    /**
     * Tells whether the given arc identifies a readable scalar object in
     * this entry.
     *
     * <p>
     *  指示给定的圆弧是否标识此条目中的可读标量对象。
     * 
     * 
     * @param arc An OID arc.
     *
     * @return <CODE>true</CODE> if `arc' leads to a readable variable.
     */
    public abstract boolean isReadable(long arc);

    /**
     * Get the next OID arc corresponding to a readable scalar variable.
     *
     * <p>
     *  获取对应于可读标量变量的下一个OID弧。
     * 
     */
    public long getNextVarId(long id, Object userData)
        throws SnmpStatusException {
        long nextvar = super.getNextVarId(id,userData);
        while (!isReadable(nextvar))
            nextvar = super.getNextVarId(nextvar,userData);
        return nextvar;
    }

    /**
     * Checks whether the given OID arc identifies a variable (columnar
     * object).
     *
     * <p>
     *  检查给定的OID是否标识变量(柱状对象)。
     * 
     * 
     * @param userData A contextual object containing user-data.
     *        This object is allocated through the <code>
     *        {@link com.sun.jmx.snmp.agent.SnmpUserDataFactory}</code>
     *        for each incoming SNMP request.
     *
     * @exception If the given `arc' does not identify any variable in this
     *    group, throws an SnmpStatusException.
     */
    public void validateVarId(long arc, Object userData)
        throws SnmpStatusException {
        if (isVariable(arc) == false) {
            throw new SnmpStatusException(SnmpDefinitions.snmpRspNoSuchName);
        }
    }

    /**
     * Generic handling of the <CODE>get</CODE> operation.
     * <p>The actual implementation of this method will be generated
     * by mibgen. Usually, this implementation only delegates the
     * job to some other provided runtime class, which knows how to
     * access the MBean. The current toolkit thus provides two
     * implementations:
     * <ul><li>The standard implementation will directly access the
     *         MBean through a java reference,</li>
     *     <li>The generic implementation will access the MBean through
     *         the MBean server.</li>
     * </ul>
     * <p>Both implementations rely upon specific - and distinct, set of
     * mibgen generated methods.
     * <p> You can override this method if you need to implement some
     * specific policies for minimizing the accesses made to some remote
     * underlying resources.
     * <p>
     *
     * <p>
     *  通用处理<CODE> get </CODE>操作。 <p>此方法的实际实现将由mibgen生成。通常,此实现仅将作业委派给某个其他提供的运行时类,该类知道如何访问MBean。
     * 因此,当前工具包提供了两种实现：<ul> <li>标准实现将通过java引用直接访问MBean,</li> <li>通用实现将通过MBean服务器访问MBean。</li>。
     * </ul>
     *  <p>这两个实现依赖于特定的和不同的mibgen生成方法集合。 <p>如果您需要实施一些特定策略以最小化对某些远程基础资源的访问,您可以覆盖此方法。
     * <p>
     * 
     * 
     * @param req   The sub-request that must be handled by this node.
     *
     * @param depth The depth reached in the OID tree.
     *
     * @exception SnmpStatusException An error occurred while accessing
     *  the MIB node.
     */
    abstract public void get(SnmpMibSubRequest req, int depth)
        throws SnmpStatusException;

    /**
     * Generic handling of the <CODE>set</CODE> operation.
     * <p>The actual implementation of this method will be generated
     * by mibgen. Usually, this implementation only delegates the
     * job to some other provided runtime class, which knows how to
     * access the MBean. The current toolkit thus provides two
     * implementations:
     * <ul><li>The standard implementation will directly access the
     *         MBean through a java reference,</li>
     *     <li>The generic implementation will access the MBean through
     *         the MBean server.</li>
     * </ul>
     * <p>Both implementations rely upon specific - and distinct, set of
     * mibgen generated methods.
     * <p> You can override this method if you need to implement some
     * specific policies for minimizing the accesses made to some remote
     * underlying resources.
     * <p>
     *
     * <p>
     * 通用处理<CODE>设置</CODE>操作。 <p>此方法的实际实现将由mibgen生成。通常,此实现仅将作业委派给某个其他提供的运行时类,该类知道如何访问MBean。
     * 因此,当前工具包提供了两种实现：<ul> <li>标准实现将通过java引用直接访问MBean,</li> <li>通用实现将通过MBean服务器访问MBean。</li>。
     * </ul>
     *  <p>这两个实现依赖于特定的和不同的mibgen生成方法集合。 <p>如果您需要实施一些特定策略以最小化对某些远程基础资源的访问,您可以覆盖此方法。
     * <p>
     * 
     * 
     * @param req   The sub-request that must be handled by this node.
     *
     * @param depth The depth reached in the OID tree.
     *
     * @exception SnmpStatusException An error occurred while accessing
     *  the MIB node.
     */
    abstract public void set(SnmpMibSubRequest req, int depth)
        throws SnmpStatusException;

    /**
     * Generic handling of the <CODE>check</CODE> operation.
     *
     * <p>The actual implementation of this method will be generated
     * by mibgen. Usually, this implementation only delegates the
     * job to some other provided runtime class, which knows how to
     * access the MBean. The current toolkit thus provides two
     * implementations:
     * <ul><li>The standard implementation will directly access the
     *         MBean through a java reference,</li>
     *     <li>The generic implementation will access the MBean through
     *         the MBean server.</li>
     * </ul>
     * <p>Both implementations rely upon specific - and distinct, set of
     * mibgen generated methods.
     * <p> You can override this method if you need to implement some
     * specific policies for minimizing the accesses made to some remote
     * underlying resources, or if you need to implement some consistency
     * checks between the different values provided in the varbind list.
     * <p>
     *
     * <p>
     *  一般处理<CODE>检查</CODE>操作。
     * 
     *  <p>此方法的实际实现将由mibgen生成。通常,此实现仅将作业委派给某个其他提供的运行时类,该类知道如何访问MBean。
     * 因此,当前工具包提供了两种实现：<ul> <li>标准实现将通过java引用直接访问MBean,</li> <li>通用实现将通过MBean服务器访问MBean。</li>。
     * </ul>
     * 
     * @param req   The sub-request that must be handled by this node.
     *
     * @param depth The depth reached in the OID tree.
     *
     * @exception SnmpStatusException An error occurred while accessing
     *  the MIB node.
     */
    abstract public void check(SnmpMibSubRequest req, int depth)
        throws SnmpStatusException;

}
