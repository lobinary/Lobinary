/***** Lobxxx Translate Finished ******/
package org.omg.PortableInterceptor;


/**
* org/omg/PortableInterceptor/ServerRequestInterceptorOperations.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u45/3627/corba/src/share/classes/org/omg/PortableInterceptor/Interceptors.idl
* Thursday, April 30, 2015 12:42:09 PM PDT
*/


/**
   * Server-side request interceptor.
   * <p>
   * A request Interceptor is designed to intercept the flow of a 
   * request/reply sequence through the ORB at specific points so that 
   * services can query the request information and manipulate the service 
   * contexts which are propagated between clients and servers. The primary 
   * use of request Interceptors is to enable ORB services to transfer 
   * context information between clients and servers. There are two types 
   * of request Interceptors: client-side and server-side. 
   * <p>
   * To write a server-side Interceptor, implement the 
   * ServerRequestInterceptor interface.
   *
   * <p>
   *  服务器端请求拦截器。
   * <p>
   *  请求拦截器被设计为在特定点处通过ORB截取请求/应答序列的流,使得服务可以查询请求信息并操纵在客户端和服务器之间传播的服务上下文。
   * 请求拦截器的主要用途是使ORB服务能够在客户端和服务器之间传递上下文信息。有两种类型的请求拦截器：客户端和服务器端。
   * <p>
   *  要编写服务器端拦截器,请实现ServerRequestInterceptor接口。
   * 
   * 
   * @see ServerRequestInfo
   */
public interface ServerRequestInterceptorOperations  extends org.omg.PortableInterceptor.InterceptorOperations
{

  /**
     * Allows the interceptor to process service context information.
     * <p>
     * At this interception point, Interceptors must get their service 
     * context information from the incoming request transfer it to 
     * <code>PortableInterceptor.Current</code>'s slots.  
     * <p>
     * This interception point is called before the servant manager is called. 
     * Operation parameters are not yet available at this point. This 
     * interception point may or may not execute in the same thread as 
     * the target invocation. 
     * <p>
     * This interception point may throw a system exception. If it does, 
     * no other Interceptors' <code>receive_request_service_contexts</code> 
     * operations are called. Those Interceptors on the Flow Stack are 
     * popped and their <code>send_exception</code> interception points are 
     * called. 
     * <p>
     * This interception point may also throw a <code>ForwardRequest</code> 
     * exception.  If an Interceptor throws this exception, no other 
     * Interceptors' <code>receive_request_service_contexts</code> operations 
     * are called. Those Interceptors on the Flow Stack are popped and 
     * their <code>send_other</code> interception points are called. 
     * <p>
     * Compliant Interceptors shall properly follow 
     * <code>completion_status</code> semantics if they throw a system 
     * exception from this interception point. The 
     * <code>completion_status</code> shall be COMPLETED_NO.
     *
     * <p>
     *  允许拦截器处理服务上下文信息。
     * <p>
     *  在这个拦截点,拦截器必须从传入的请求中获得它们的服务上下文信息,将其传送到<code> PortableInterceptor.Current </code>的时隙。
     * <p>
     *  这个拦截点在调用servant管理器之前调用。此时,操作参数尚不可用。这个拦截点可以或可以不在与目标调用相同的线程中执行。
     * <p>
     * 这个拦截点可能会抛出系统异常。如果是,则不调用其他拦截器的<code> receive_request_service_contexts </code>操作。
     * 流栈上的拦截器被弹出,它们的<code> send_exception </code>拦截点被调用。
     * <p>
     *  这个拦截点也可能引发一个<code> ForwardRequest </code>异常。
     * 如果拦截器抛出此异常,则不会调用其他拦截器的<code> receive_request_service_contexts </code>操作。
     * 流栈上的拦截器被弹出,它们的<code> send_other </code>拦截点被调用。
     * <p>
     *  如果符合规则的拦截器从此拦截点抛出系统异常,则应正确遵循<code> completion_status </code>语义。
     *  <code> completion_status </code>应为COMPLETED_NO。
     * 
     * 
     * @param ri Information about the current request being intercepted.
     * @exception ForwardRequest If thrown, indicates to the ORB that a
     *     retry of the request should occur with the new object given in
     *     the exception.
     */
  void receive_request_service_contexts (org.omg.PortableInterceptor.ServerRequestInfo ri) throws org.omg.PortableInterceptor.ForwardRequest;

  /**
     * Allows an Interceptor to query request information after all the 
     * information, including operation parameters, are available. This 
     * interception point shall execute in the same thread as the target 
     * invocation.
     * <p>
     * In the DSI model, since the parameters are first available when 
     * the user code calls <code>arguments</code>, <code>receive_request</code>
     * is called from within <code>arguments</code>. It is possible that 
     * <code>arguments</code> is not called in the DSI model. The target 
     * may call <code>set_exception</code> before calling 
     * <code>arguments</code>. The ORB shall guarantee that 
     * <code>receive_request</code> is called once, either through 
     * <code>arguments</code> or through <code>set_exception</code>. If it 
     * is called through <code>set_exception</code>, requesting the 
     * arguments will result in <code>NO_RESOURCES</code> being thrown with 
     * a standard minor code of 1. 
     * <p>
     * This interception point may throw a system exception. If it does, no 
     * other Interceptors' <code>receive_request</code> operations are 
     * called. Those Interceptors on the Flow Stack are popped and their 
     * <code>send_exception</code> interception points are called. 
     * <p>
     * This interception point may also throw a <code>ForwardRequest</code> 
     * exception.  If an Interceptor throws this exception, no other 
     * Interceptors' <code>receive_request</code> operations are called. 
     * Those Interceptors on the Flow Stack are popped and their 
     * <code>send_other</code> interception points are called.
     * <p>
     * Compliant Interceptors shall properly follow 
     * <code>completion_status</code> semantics if they throw a system 
     * exception from this interception point. The 
     * <code>completion_status</code> shall be <code>COMPLETED_NO</code>.
     *
     * <p>
     *  允许拦截器在所有信息(包括操作参数)可用后查询请求信息。这个拦截点应在与目标调用相同的线程中执行。
     * <p>
     * 在DSI模型中,由于当用户代码调用<code> arguments </code>时,参数首先可用,因此<code> arguments </code>内调用<code> receive_request
     *  </code>。
     * 可能在DSI模型中未调用<code> arguments </code>。目标可以在调用<code>参数</code>之前调用<code> set_exception </code>。
     *  ORB应保证通过<code> arguments </code>或通过<code> set_exception </code>调用<code> receive_request </code>一次。
     * 如果通过<code> set_exception </code>调用,请求参数将导致<code> NO_RESOURCES </code>被抛出,标准次要代码为1。
     * <p>
     *  这个拦截点可能会抛出系统异常。如果是,则不调用其他拦截器的<code> receive_request </code>操作。
     * 流栈上的拦截器被弹出,它们的<code> send_exception </code>拦截点被调用。
     * <p>
     *  这个拦截点也可能引发一个<code> ForwardRequest </code>异常。如果拦截器抛出此异常,则不会调用其他拦截器的<code> receive_request </code>操作。
     * 流栈上的拦截器被弹出,它们的<code> send_other </code>拦截点被调用。
     * <p>
     *  如果符合规则的拦截器从此拦截点抛出系统异常,则应正确遵循<code> completion_status </code>语义。
     *  <code> completion_status </code>应为<code> COMPLETED_NO </code>。
     * 
     * 
     * @param ri Information about the current request being intercepted.
     * @exception ForwardRequest If thrown, indicates to the ORB that a
     *     retry of the request should occur with the new object given in
     *     the exception.
     */
  void receive_request (org.omg.PortableInterceptor.ServerRequestInfo ri) throws org.omg.PortableInterceptor.ForwardRequest;

  /**
     * Allows an Interceptor to query reply information and modify the 
     * reply service context after the target operation has been invoked 
     * and before the reply is returned to the client. This interception 
     * point shall execute in the same thread as the target invocation. 
     * <p>
     * This interception point may throw a system exception. If it does, 
     * no other Interceptors' <code>send_reply</code> operations are called. 
     * The remaining Interceptors in the Flow Stack shall have their 
     * <code>send_exception</code> interception point called. 
     * <p>
     * Compliant Interceptors shall properly follow 
     * <code>completion_status</code> semantics if they throw a 
     * system exception from this interception point. The 
     * <code>completion_status</code> shall be <code>COMPLETED_YES</code>.
     *
     * <p>
     * 允许拦截器在调用目标操作之后和在将回复返回给客户端之前查询回复信息并修改回复服务上下文。这个拦截点应在与目标调用相同的线程中执行。
     * <p>
     *  这个拦截点可能会抛出系统异常。如果是,则不调用其他拦截器的<code> send_reply </code>操作。
     * 流栈中剩余的拦截器应该调用其<code> send_exception </code>拦截点。
     * <p>
     *  如果符合规则的拦截器从此拦截点抛出系统异常,则应正确遵循<code> completion_status </code>语义。
     *  <code> completion_status </code>应为<code> COMPLETED_YES </code>。
     * 
     * 
     * @param ri Information about the current request being intercepted.
     */
  void send_reply (org.omg.PortableInterceptor.ServerRequestInfo ri);

  /**
     * Allows an Interceptor to query the exception information and modify 
     * the reply service context before the exception is thrown to the client. 
     * When an exception occurs, this interception point is called. This 
     * interception point shall execute in the same thread as the target 
     * invocation. 
     * <p>
     * This interception point may throw a system exception. This has the 
     * effect of changing the exception which successive Interceptors 
     * popped from the Flow Stack receive on their calls to 
     * <code>send_exception</code>. The exception thrown to the client will 
     * be the last exception thrown by an Interceptor, or the original 
     * exception if no Interceptor changes the exception. 
     * <p>
     * This interception point may also throw a <code>ForwardRequest</code> 
     * exception.  If an Interceptor throws this exception, no other 
     * Interceptors' <code>send_exception</code> operations are called. The 
     * remaining Interceptors in the Flow Stack shall have their 
     * <code>send_other</code> interception points called. 
     * <p>
     * If the <code>completion_status</code> of the exception is not 
     * <code>COMPLETED_NO</code>, then it is inappropriate for this 
     * interception point to throw a <code>ForwardRequest</code> exception. 
     * The request's at-most-once semantics would be lost. 
     * <p>
     * Compliant Interceptors shall properly follow 
     * <code>completion_status</code> semantics if they throw a system 
     * exception from this interception point. If the original exception 
     * is a system exception, the <code>completion_status</code> of the new 
     * exception shall be the same as on the original. If the original 
     * exception is a user exception, then the <code>completion_status</code> 
     * of the new exception shall be <code>COMPLETED_YES</code>.
     *
     * <p>
     *  允许拦截器在异常抛出到客户端之前查询异常信息并修改回复服务上下文。当发生异常时,调用这个拦截点。这个拦截点应在与目标调用相同的线程中执行。
     * <p>
     *  这个拦截点可能会抛出系统异常。这具有改变从流栈中弹出的连续拦截器在其对<code> send_exception </code>的调用时接收的异常的效果。
     * 抛出给客户端的异常将是拦截器抛出的最后一个异常,或者如果没有拦截器更改异常,则抛出原始异常。
     * <p>
     * 这个拦截点也可能引发一个<code> ForwardRequest </code>异常。如果拦截器抛出此异常,则不会调用其他拦截器的<code> send_exception </code>操作。
     * 流栈中剩余的拦截器应该调用它们的<code> send_other </code>拦截点。
     * <p>
     *  如果异常的<code> completion_status </code>不是<code> COMPLETED_NO </code>,那么这个拦截点不应该抛出一个<code> ForwardReque
     * st </code>异常。
     * 请求的最多一次语义将丢失。
     * <p>
     *  如果符合规则的拦截器从此拦截点抛出系统异常,则应正确遵循<code> completion_status </code>语义。
     * 如果原始异常是系统异常,则新异常的<code> completion_status </code>应与原始异常相同。
     * 如果原始异常是用户异常,则新异常的<code> completion_status </code>应为<code> COMPLETED_YES </code>。
     * 
     * @param ri Information about the current request being intercepted.
     * @exception ForwardRequest If thrown, indicates to the ORB that a
     *     retry of the request should occur with the new object given in
     *     the exception.
     */
  void send_exception (org.omg.PortableInterceptor.ServerRequestInfo ri) throws org.omg.PortableInterceptor.ForwardRequest;

  /**
     * Allows an Interceptor to query the information available when a 
     * request results in something other than a normal reply or an 
     * exception. For example, a request could result in a retry 
     * (e.g., a GIOP Reply with a <code>LOCATION_FORWARD</code> status was 
     * received). This interception point shall execute in the same thread 
     * as the target invocation. 
     * <p>
     * This interception point may throw a system exception. If it does, 
     * no other Interceptors' <code>send_other</code> operations are called. 
     * The remaining Interceptors in the Flow Stack shall have their 
     * <code>send_exception</code> interception points called. 
     * <p>
     * This interception point may also throw a <code>ForwardRequest</code> 
     * exception.  If an Interceptor throws this exception, successive 
     * Interceptors' <code>send_other</code> operations are called with 
     * the new information provided by the <code>ForwardRequest</code> 
     * exception. 
     * <p>
     * Compliant Interceptors shall properly follow 
     * <code>completion_status</code> semantics if they throw a system 
     * exception from this interception point. The 
     * <code>completion_status</code> shall be <code>COMPLETED_NO</code>.
     *
     * <p>
     * 
     * 
     * @param ri Information about the current request being intercepted.
     * @exception ForwardRequest If thrown, indicates to the ORB that a
     *     retry of the request should occur with the new object given in
     *     the exception.
     */
  void send_other (org.omg.PortableInterceptor.ServerRequestInfo ri) throws org.omg.PortableInterceptor.ForwardRequest;
} // interface ServerRequestInterceptorOperations
