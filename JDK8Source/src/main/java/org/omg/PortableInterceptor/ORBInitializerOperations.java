/***** Lobxxx Translate Finished ******/
package org.omg.PortableInterceptor;


/**
* org/omg/PortableInterceptor/ORBInitializerOperations.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from c:/re/workspace/8-2-build-windows-amd64-cygwin/jdk8u45/3627/corba/src/share/classes/org/omg/PortableInterceptor/Interceptors.idl
* Thursday, April 30, 2015 12:42:09 PM PDT
*/


/**
   * Facilitates interceptor registration and ORB initialization.
   * <p>
   * Interceptors are intended to be a means by which ORB services gain 
   * access to ORB processing, effectively becoming part of the ORB. 
   * Since Interceptors are part of the ORB, when <code>ORB.init</code> 
   * returns an ORB, the Interceptors shall have been registered. 
   * Interceptors cannot be registered on an ORB after it has been 
   * returned by a call to <code>ORB.init</code>.
   * <p>
   * An Interceptor is registered by registering an associated 
   * <code>ORBInitializer</code> object which implements the 
   * <code>ORBInitializer</code> interface. When an ORB is initializing, 
   * it shall call each registered <code>ORBInitializer</code>, passing it 
   * an <code>ORBInitInfo</code> object which is used to register its 
   * Interceptor.
   * <p>
   * <b>Registering ORB Initializers in Java</b>
   * <p>
   * ORBInitializers are registered via Java ORB properties.
   * <p>
   * The property names are of the form: 
   *   <blockquote><code>
   *     org.omg.PortableInterceptor.ORBInitializerClass.&lt;Service&gt;
   *   </code></blockquote>
   * where <code>&lt;Service&gt;</code> is the string name of a class 
   * which implements 
   *   <blockquote><code>
   *     org.omg.PortableInterceptor.ORBInitializer
   *   </code></blockquote>
   * To avoid name collisions, the reverse DNS name convention should be 
   * used. For example, if company X has three initializers, it could define 
   * the following properties: 
   * <ul>
   *   <li><code>
   *     org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init1
   *   </code></li>
   *   <li><code>
   *     org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init2
   *   </code></li>
   *   <li><code>
   *     org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init3
   *   </code></li>
   * </ul>
   * During ORB.init, these ORB properties which begin with 
   * <code>org.omg.PortableInterceptor.ORBInitializerClass</code> shall be 
   * collected, the <code>&lt;Service&gt;</code> portion of each property 
   * shall be extracted, an object shall be instantiated with the 
   * <code>&lt;Service&gt;</code> string as its class name, and the 
   * <code>pre_init</code> and <code>post_init</code> methods shall be 
   * called on that object. If there are any exceptions, the ORB shall 
   * ignore them and proceed. 
   * <p>
   * <b><i>Example</i></b>
   * <p>
   * A client-side logging service written by company X, for example, may 
   * have the following ORBInitializer implementation: 
   * <code><pre>
   * package com.x.logging;
   * 
   * import org.omg.PortableInterceptor.Interceptor; 
   * import org.omg.PortableInterceptor.ORBInitializer; 
   * import org.omg.PortableInterceptor.ORBInitInfo; 
   * 
   * public class LoggingService implements ORBInitializer { 
   *     void pre_init( ORBInitInfo info ) { 
   *         // Instantiate the Logging Service s Interceptor. 
   *         Interceptor interceptor = new LoggingInterceptor(); 
   *
   *         // Register the Logging Service s Interceptor. 
   *         info.add_client_request_interceptor( interceptor ); 
   *     } 
   * 
   *     void post_init( ORBInitInfo info ) { 
   *         // This service does not need two init points. 
   *     } 
   * } 
   * </pre></code>
   * To run a program called <code>MyApp</code> using this logging 
   * service, the user could type: 
   *   <blockquote><code>
   *     java 
   *-Dorg.omg.PortableInterceptor.ORBInitializerClass.com.x.Logging.LoggingService 
   *     MyApp
   *   </code></blockquote>
   * <p>
   * <b>Notes about Registering Interceptors</b>
   * <p>
   * Request Interceptors are registered on a per-ORB basis. 
   * <p>
   * To achieve virtual per-object Interceptors, query the policies on the 
   * target from within the interception points to determine whether they 
   * should do any work. 
   * <p>
   * To achieve virtual per-POA Interceptors, instantiate each POA with a 
   * different ORB. While Interceptors may be ordered administratively, 
   * there is no concept of order with respect to the registration of 
   * Interceptors. Request Interceptors are concerned with service contexts. 
   * Service contexts have no order, so there is no purpose for request 
   * Interceptors to have an order. IOR Interceptors are concerned with 
   * tagged components. Tagged components also have no order, so there 
   * is no purpose for IOR Interceptors to have an order. 
   * <p>
   * Registration code should avoid using the ORB (i.e., calling 
   * <code>ORB.init</code> with the provided <code>orb_id</code>). Since 
   * registration occurs during ORB initialization, results of invocations 
   * on this ORB while it is in this state are undefined. 
   * 
   * <p>
   *  促进拦截器注册和ORB初始化。
   * <p>
   *  拦截器意在作为一种手段,通过它ORB服务获得对ORB处理的访问,有效地成为ORB的一部分。
   * 由于拦截器是ORB的一部分,当<code> ORB.init </code>返回一个ORB时,拦截器应该已经注册。
   * 在通过调用<code> ORB.init </code>返回之后,拦截器不能在ORB上注册。
   * <p>
   *  通过注册实现<code> ORBInitializer </code>接口的关联<code> ORBInitializer </code>对象来注册拦截器。
   * 当ORB初始化时,它将调用每个注册的<code> ORBInitializer </code>,并传递一个用于注册其Interceptor的<code> ORBInitInfo </code>对象。
   * <p>
   *  <b>在Java中注册ORB初始化程序</b>
   * <p>
   *  ORBInitializers通过Java ORB属性注册。
   * <p>
   * 属性名的格式为：<blockquote> <code> org.omg.PortableInterceptor.ORBInitializerClass。
   * &lt; Service&gt; </code> </blockquote>其中<code>&lt; Service&gt; </code>是实现<blockquote> <code> org.omg.
   * PortableInterceptor.ORBInitializer </code> </blockquote>为了避免名称冲突,应使用反向DNS名称约定。
   * 属性名的格式为：<blockquote> <code> org.omg.PortableInterceptor.ORBInitializerClass。
   * 例如,如果公司X有三个初始化器,它可以定义以下属性：。
   * <ul>
   *  <li> <code> org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init1 </code> </li> <li> <code> or
   * g.omg.PortableInterceptor.ORBInitializerClass.com.x.Init1 </li> </li> <li> <code> org.omg.PortableInt
   * erceptor.ORBInitializerClass.com.x.Init3 </code> </li>。
   * </ul>
   *  在ORB.init中,应收集以<code> org.omg.PortableInterceptor.ORBInitializerClass </code>开头的这些ORB属性,应提取每个属性的<code>
   * &lt; Service&gt; </code>部分,对象应以<code>&lt; Service&gt; </code>字符串作为其类名来实例化,并且应该在该对象上调用<code> pre_init 
   * </code>和<code> post_init </code>方法。
   * 如果有任何异常,ORB将忽略它们并继续。
   * <p>
   *  <b> <i>示例</i> </b>
   * <p>
   *  例如,由公司X编写的客户端日志记录服务可以具有以下ORBInitializer实现：<code> <pre> package com.x.logging;
   * 
   * import org.omg.PortableInterceptor.Interceptor; import org.omg.PortableInterceptor.ORBInitializer; im
   * port org.omg.PortableInterceptor.ORBInitInfo;。
   * 
   * 
   * @see ORBInitInfo
   */
public interface ORBInitializerOperations 
{

  /** 
     * Called during ORB initialization.  If it is expected that initial 
     * services registered by an interceptor will be used by other 
     * interceptors, then those initial services shall be registered at 
     * this point via calls to 
     * <code>ORBInitInfo.register_initial_reference</code>. 
     * 
     * <p>
     *  public class LoggingService implements ORBInitializer {void pre_init(ORBInitInfo info){//实例化日志服务的拦截器。
     * 拦截器拦截器= new LoggingInterceptor();。
     * 
     *  //注册日志记录服务的拦截器。 info.add_client_request_interceptor(interceptor); }}
     * 
     *  void post_init(ORBInitInfo info){//此服务不需要两个init点。
     *  }} </pre> </code>要使用此日志服务运行一个名为<code> MyApp </code>的程序,用户可以键入：<blockquote> <code> java Dorg.omg.Port
     * ableInterceptor.ORBInitializerClass.com。
     *  void post_init(ORBInitInfo info){//此服务不需要两个init点。
     *  x.Logging.LoggingService MyApp </code> </blockquote>。
     * <p>
     *  <b>注册拦截器注意事项</b>
     * <p>
     *  请求拦截器以每个ORB为基础进行注册。
     * <p>
     *  要实现虚拟的每个对象拦截器,从拦截点内查询目标上的策略,以确定它们是否应该执行任何工作。
     * <p>
     * 
     * @param info provides initialization attributes and operations by 
     *     which Interceptors can be registered.
     */
  void pre_init (org.omg.PortableInterceptor.ORBInitInfo info);

  /**
     * Called during ORB initialization. If a service must resolve initial 
     * references as part of its initialization, it can assume that all 
     * initial references will be available at this point. 
     * <p>
     * Calling the <code>post_init</code> operations is not the final 
     * task of ORB initialization. The final task, following the 
     * <code>post_init</code> calls, is attaching the lists of registered 
     * interceptors to the ORB. Therefore, the ORB does not contain the 
     * interceptors during calls to <code>post_init</code>. If an 
     * ORB-mediated call is made from within <code>post_init</code>, no 
     * request interceptors will be invoked on that call. 
     * Likewise, if an operation is performed which causes an IOR to be 
     * created, no IOR interceptors will be invoked. 
     *
     * <p>
     * 为了实现虚拟每POA拦截器,用不同的ORB实例化每个POA。虽然拦截者可以行政命令,但是没有关于拦截者注册的秩序概念。请求拦截器关心服务上下文。服务上下文没有顺序,因此请求拦截器没有任何目的。
     *  IOR拦截器涉及标记的组件。标记的组件也没有顺序,因此IOR拦截器没有任何目的。
     * <p>
     *  注册码应避免使用ORB(即,使用提供的<code> orb_id </code>调用<code> ORB.init </code>)。
     * 由于注册在ORB初始化期间发生,所以在ORB处于此状态时对其进行调用的结果是未定义的。
     * 
     * 
     * @param info provides initialization attributes and 
     *     operations by which Interceptors can be registered.
     */
  void post_init (org.omg.PortableInterceptor.ORBInitInfo info);
} // interface ORBInitializerOperations
